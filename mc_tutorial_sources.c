/*

Original mc_workshop source codes used during the tutorial.

mc_code.html from mc_tutorial.zip (http://www.bayfronttechnologies.com/mc_tutorial.zip)
mc_input.html from mc_tutorial.zip (http://www.bayfronttechnologies.com/mc_tutorial.zip)

Original code in Javascript

Copyright 2006, 2008 Bayfront Technologies, Inc. http://www.BayfrontTechnologies.com/mc_workshop.html

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice, URL, and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


Transposed to C for use as testkit for C based META II VM by Daniel Chapiesky

Javascript "code" entries are not included. (obviously since they need js to run... heh)


Available Input Texts Are:
	0	i01. demo, AEXP example assignments
	1	i02. demo, AEXP example assignment compiler
	2	i03. Meta II syntax (paper fig. 5)
	3	i04. Meta II syntax (i03 reordered)
	4	i05. add semicolon line end
	5	i06. use semicolon line end
	6	i07. add new output control
	7	i08. delete old output control
	8	i09. use new output control
	9	i10. convert i09 to js functions
	10	i11. add token rules to i09
	11	i11jf. add token rules to i10
	12	i12. use token rules
	13	i12jf. use token rules
	14	i13. add comments and litchr to i12
	15	i13jf. add comments and litchr to i12jf
	16	i14. use comments and litchr
	17	i14jf. use comments and litchr
	18	i14js. convert i14jf to js object
	19	i02a. demo, AEXP example assignment compiler
	20	i01a. demo, AEXP2 backup value assignments
	21	i15js. js metacompiler with backup
	22	i02b. demo, AEXP2 backup assignment compiler
	23	i04a. Meta II syntax (i03 reordered and tokens)


Available Codes Are:
	0	c00. demo, compiled assignments c[i01,c01] 
	1	c01. demo, AEXP assignments compiler c[i02,c02] 
	2	c02. Meta II of fig. 5, m[i03,c02]
	3	c03. Meta II reordered, c[i04,c02], m[i04,c03]
	4	c04. Meta II semicolons, c[i05,c03], m[i06,c04]
	5	c05. accept new output, c[i07,c04], m[i07,c05]
	6	c06. reject old output, c[i08,c05]
	7	c07. use new output, c[i09,c06], m[i09,c07]
	8	c08. compile to js functions, c[i10,c07]
	9	c09. accept tokens, c[i11,c07]
	10	c10. use tokens, c[i12,c09], m[i12,c10]
	11	c11. accept comments, c[i13,c10]
	12	c12. use comments, c[i14,c11], m[i14,c12]


*/

typedef struct meta_compiler_workshop_sources_struct {
	const char *menu;
	const char *text;
} meta_compiler_workshop_sources;


void get_meta_compiler_workshop_sources_for_Code(meta_compiler_workshop_sources *Code, int *return_count);
void get_meta_compiler_workshop_sources_for_Input(meta_compiler_workshop_sources *Input, int *return_count);


/// Fill an array of meta_compiler_workshop_sources with the string constants of Code for the meta compiler workshop
/// The array must be large enough to accommodate the number Code entries
///
void get_meta_compiler_workshop_sources_for_Code(meta_compiler_workshop_sources *Code, int *return_count) 
{
	int index;

	index = 0;

	Code[index].menu = "c00. demo, compiled assignments c[i01,c01] " ;
	Code[index].text =
	"\taddress fern\n"
	"\tliteral 5\n"
	"\tliteral 6\n"
	"\tadd\n"
	"\tstore\n"
	"\taddress ace\n"
	"\tload fern\n"
	"\tliteral 5\n"
	"\tmpy\n"
	"\tstore\n"
	"\taddress waldo\n"
	"\tload fern\n"
	"\tload alpha\n"
	"\tload beta\n"
	"\tminus\n"
	"\tload gamma\n"
	"\texp\n"
	"\tdiv\n"
	"\tadd\n"
	"\tstore\n";

	index++ ;
	Code[index].menu = "c01. demo, AEXP assignments compiler c[i02,c02] " ;
	Code[index].text =
	"\tADR AEXP\n"
	"AEXP\n"
	"\tCLL AS\n"
	"\tBF L1\n"
	"L2\n"
	"\tCLL AS\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"AS\n"
	"\tID\n"
	"\tBF L4\n"
	"\tCL 'address '\n"
	"\tCI\n"
	"\tOUT\n"
	"\tTST ':='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tCL 'store'\n"
	"\tOUT\n"
	"\tTST ';'\n"
	"\tBE\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '+'\n"
	"\tBF L8\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"\tCL 'add'\n"
	"\tOUT\n"
	"L8\n"
	"\tBT L9\n"
	"\tTST '-'\n"
	"\tBF L10\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"\tCL 'sub'\n"
	"\tOUT\n"
	"L10\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"L6\n"
	"L11\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L12\n"
	"L13\n"
	"\tTST '*'\n"
	"\tBF L14\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'mpy'\n"
	"\tOUT\n"
	"L14\n"
	"\tBT L15\n"
	"\tTST '/'\n"
	"\tBF L16\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'div'\n"
	"\tOUT\n"
	"L16\n"
	"L15\n"
	"\tBT L13\n"
	"\tSET\n"
	"\tBE\n"
	"L12\n"
	"L17\n"
	"\tR\n"
	"EX3\n"
	"\tCLL EX4\n"
	"\tBF L18\n"
	"L19\n"
	"\tTST '^'\n"
	"\tBF L20\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'exp'\n"
	"\tOUT\n"
	"L20\n"
	"L21\n"
	"\tBT L19\n"
	"\tSET\n"
	"\tBE\n"
	"L18\n"
	"L22\n"
	"\tR\n"
	"EX4\n"
	"\tTST '+'\n"
	"\tBF L23\n"
	"\tCLL EX5\n"
	"\tBE\n"
	"L23\n"
	"\tBT L24\n"
	"\tTST '-'\n"
	"\tBF L25\n"
	"\tCLL EX5\n"
	"\tBE\n"
	"\tCL 'minus'\n"
	"\tOUT\n"
	"L25\n"
	"\tBT L24\n"
	"\tCLL EX5\n"
	"\tBF L26\n"
	"L26\n"
	"L24\n"
	"\tR\n"
	"EX5\n"
	"\tID\n"
	"\tBF L27\n"
	"\tCL 'load '\n"
	"\tCI\n"
	"\tOUT\n"
	"L27\n"
	"\tBT L28\n"
	"\tNUM\n"
	"\tBF L29\n"
	"\tCL 'literal '\n"
	"\tCI\n"
	"\tOUT\n"
	"L29\n"
	"\tBT L28\n"
	"\tTST '('\n"
	"\tBF L30\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L30\n"
	"L28\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c02. Meta II of fig. 5, m[i03,c02]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"OUT1\n"
	"\tTST '*1'\n"
	"\tBF L1\n"
	"\tCL 'GN1'\n"
	"\tOUT\n"
	"L1\n"
	"\tBT L2\n"
	"\tTST '*2'\n"
	"\tBF L3\n"
	"\tCL 'GN2'\n"
	"\tOUT\n"
	"L3\n"
	"\tBT L2\n"
	"\tTST '*'\n"
	"\tBF L4\n"
	"\tCL 'CI'\n"
	"\tOUT\n"
	"L4\n"
	"\tBT L2\n"
	"\tSR\n"
	"\tBF L5\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L5\n"
	"L2\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L6\n"
	"\tTST '('\n"
	"\tBE\n"
	"L7\n"
	"\tCLL OUT1\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L6\n"
	"\tBT L8\n"
	"\tTST '.LABEL'\n"
	"\tBF L9\n"
	"\tCL 'LB'\n"
	"\tOUT\n"
	"\tCLL OUT1\n"
	"\tBE\n"
	"L9\n"
	"L8\n"
	"\tBF L10\n"
	"\tCL 'OUT'\n"
	"\tOUT\n"
	"L10\n"
	"L11\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L12\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L12\n"
	"\tBT L13\n"
	"\tSR\n"
	"\tBF L14\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tOUT\n"
	"L14\n"
	"\tBT L13\n"
	"\tTST '.ID'\n"
	"\tBF L15\n"
	"\tCL 'ID'\n"
	"\tOUT\n"
	"L15\n"
	"\tBT L13\n"
	"\tTST '.NUMBER'\n"
	"\tBF L16\n"
	"\tCL 'NUM'\n"
	"\tOUT\n"
	"L16\n"
	"\tBT L13\n"
	"\tTST '.STRING'\n"
	"\tBF L17\n"
	"\tCL 'SR'\n"
	"\tOUT\n"
	"L17\n"
	"\tBT L13\n"
	"\tTST '('\n"
	"\tBF L18\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L18\n"
	"\tBT L13\n"
	"\tTST '.EMPTY'\n"
	"\tBF L19\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L19\n"
	"\tBT L13\n"
	"\tTST '$'\n"
	"\tBF L20\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L20\n"
	"L13\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L21\n"
	"\tCL 'BF '\n"
	"\tGN1\n"
	"\tOUT\n"
	"L21\n"
	"\tBT L22\n"
	"\tCLL OUTPUT\n"
	"\tBF L23\n"
	"L23\n"
	"L22\n"
	"\tBF L24\n"
	"L25\n"
	"\tCLL EX3\n"
	"\tBF L26\n"
	"\tCL 'BE'\n"
	"\tOUT\n"
	"L26\n"
	"\tBT L27\n"
	"\tCLL OUTPUT\n"
	"\tBF L28\n"
	"L28\n"
	"L27\n"
	"\tBT L25\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L24\n"
	"L29\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L30\n"
	"L31\n"
	"\tTST '/'\n"
	"\tBF L32\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L32\n"
	"L33\n"
	"\tBT L31\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L30\n"
	"L34\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L35\n"
	"\tLB\n"
	"\tCI\n"
	"\tOUT\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST '.,'\n"
	"\tBE\n"
	"\tCL 'R'\n"
	"\tOUT\n"
	"L35\n"
	"L36\n"
	"\tR\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L37\n"
	"\tID\n"
	"\tBE\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tOUT\n"
	"L38\n"
	"\tCLL ST\n"
	"\tBT L38\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tCL 'END'\n"
	"\tOUT\n"
	"L37\n"
	"L39\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c03. Meta II reordered, c[i04,c02], m[i04,c03]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tOUT\n"
	"L2\n"
	"\tCLL ST\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tCL 'END'\n"
	"\tOUT\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L4\n"
	"\tLB\n"
	"\tCI\n"
	"\tOUT\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST '.,'\n"
	"\tBE\n"
	"\tCL 'R'\n"
	"\tOUT\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '/'\n"
	"\tBF L8\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L8\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L6\n"
	"L10\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L11\n"
	"\tCL 'BF '\n"
	"\tGN1\n"
	"\tOUT\n"
	"L11\n"
	"\tBT L12\n"
	"\tCLL OUTPUT\n"
	"\tBF L13\n"
	"L13\n"
	"L12\n"
	"\tBF L14\n"
	"L15\n"
	"\tCLL EX3\n"
	"\tBF L16\n"
	"\tCL 'BE'\n"
	"\tOUT\n"
	"L16\n"
	"\tBT L17\n"
	"\tCLL OUTPUT\n"
	"\tBF L18\n"
	"L18\n"
	"L17\n"
	"\tBT L15\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L14\n"
	"L19\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L20\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L20\n"
	"\tBT L21\n"
	"\tSR\n"
	"\tBF L22\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tOUT\n"
	"L22\n"
	"\tBT L21\n"
	"\tTST '.ID'\n"
	"\tBF L23\n"
	"\tCL 'ID'\n"
	"\tOUT\n"
	"L23\n"
	"\tBT L21\n"
	"\tTST '.NUMBER'\n"
	"\tBF L24\n"
	"\tCL 'NUM'\n"
	"\tOUT\n"
	"L24\n"
	"\tBT L21\n"
	"\tTST '.STRING'\n"
	"\tBF L25\n"
	"\tCL 'SR'\n"
	"\tOUT\n"
	"L25\n"
	"\tBT L21\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L21\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L27\n"
	"\tBT L21\n"
	"\tTST '$'\n"
	"\tBF L28\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L28\n"
	"L21\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L29\n"
	"\tTST '('\n"
	"\tBE\n"
	"L30\n"
	"\tCLL OUT1\n"
	"\tBT L30\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"\tBT L31\n"
	"\tTST '.LABEL'\n"
	"\tBF L32\n"
	"\tCL 'LB'\n"
	"\tOUT\n"
	"\tCLL OUT1\n"
	"\tBE\n"
	"L32\n"
	"L31\n"
	"\tBF L33\n"
	"\tCL 'OUT'\n"
	"\tOUT\n"
	"L33\n"
	"L34\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*1'\n"
	"\tBF L35\n"
	"\tCL 'GN1'\n"
	"\tOUT\n"
	"L35\n"
	"\tBT L36\n"
	"\tTST '*2'\n"
	"\tBF L37\n"
	"\tCL 'GN2'\n"
	"\tOUT\n"
	"L37\n"
	"\tBT L36\n"
	"\tTST '*'\n"
	"\tBF L38\n"
	"\tCL 'CI'\n"
	"\tOUT\n"
	"L38\n"
	"\tBT L36\n"
	"\tSR\n"
	"\tBF L39\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L39\n"
	"L36\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c04. Meta II semicolons, c[i05,c03], m[i06,c04]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tOUT\n"
	"L2\n"
	"\tCLL ST\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tCL 'END'\n"
	"\tOUT\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L4\n"
	"\tLB\n"
	"\tCI\n"
	"\tOUT\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tCL 'R'\n"
	"\tOUT\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '/'\n"
	"\tBF L8\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L8\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L6\n"
	"L10\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L11\n"
	"\tCL 'BF '\n"
	"\tGN1\n"
	"\tOUT\n"
	"L11\n"
	"\tBT L12\n"
	"\tCLL OUTPUT\n"
	"\tBF L13\n"
	"L13\n"
	"L12\n"
	"\tBF L14\n"
	"L15\n"
	"\tCLL EX3\n"
	"\tBF L16\n"
	"\tCL 'BE'\n"
	"\tOUT\n"
	"L16\n"
	"\tBT L17\n"
	"\tCLL OUTPUT\n"
	"\tBF L18\n"
	"L18\n"
	"L17\n"
	"\tBT L15\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L14\n"
	"L19\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L20\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L20\n"
	"\tBT L21\n"
	"\tSR\n"
	"\tBF L22\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tOUT\n"
	"L22\n"
	"\tBT L21\n"
	"\tTST '.ID'\n"
	"\tBF L23\n"
	"\tCL 'ID'\n"
	"\tOUT\n"
	"L23\n"
	"\tBT L21\n"
	"\tTST '.NUMBER'\n"
	"\tBF L24\n"
	"\tCL 'NUM'\n"
	"\tOUT\n"
	"L24\n"
	"\tBT L21\n"
	"\tTST '.STRING'\n"
	"\tBF L25\n"
	"\tCL 'SR'\n"
	"\tOUT\n"
	"L25\n"
	"\tBT L21\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L21\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L27\n"
	"\tBT L21\n"
	"\tTST '$'\n"
	"\tBF L28\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L28\n"
	"L21\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L29\n"
	"\tTST '('\n"
	"\tBE\n"
	"L30\n"
	"\tCLL OUT1\n"
	"\tBT L30\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"\tBT L31\n"
	"\tTST '.LABEL'\n"
	"\tBF L32\n"
	"\tCL 'LB'\n"
	"\tOUT\n"
	"\tCLL OUT1\n"
	"\tBE\n"
	"L32\n"
	"L31\n"
	"\tBF L33\n"
	"\tCL 'OUT'\n"
	"\tOUT\n"
	"L33\n"
	"L34\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*1'\n"
	"\tBF L35\n"
	"\tCL 'GN1'\n"
	"\tOUT\n"
	"L35\n"
	"\tBT L36\n"
	"\tTST '*2'\n"
	"\tBF L37\n"
	"\tCL 'GN2'\n"
	"\tOUT\n"
	"L37\n"
	"\tBT L36\n"
	"\tTST '*'\n"
	"\tBF L38\n"
	"\tCL 'CI'\n"
	"\tOUT\n"
	"L38\n"
	"\tBT L36\n"
	"\tSR\n"
	"\tBF L39\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L39\n"
	"L36\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c05. accept new output, c[i07,c04], m[i07,c05]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tOUT\n"
	"L2\n"
	"\tCLL ST\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tCL 'END'\n"
	"\tOUT\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L4\n"
	"\tLB\n"
	"\tCI\n"
	"\tOUT\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tCL 'R'\n"
	"\tOUT\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '/'\n"
	"\tBF L8\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L8\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L6\n"
	"L10\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L11\n"
	"\tCL 'BF '\n"
	"\tGN1\n"
	"\tOUT\n"
	"L11\n"
	"\tBT L12\n"
	"\tCLL OUTPUT\n"
	"\tBF L13\n"
	"L13\n"
	"L12\n"
	"\tBF L14\n"
	"L15\n"
	"\tCLL EX3\n"
	"\tBF L16\n"
	"\tCL 'BE'\n"
	"\tOUT\n"
	"L16\n"
	"\tBT L17\n"
	"\tCLL OUTPUT\n"
	"\tBF L18\n"
	"L18\n"
	"L17\n"
	"\tBT L15\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L14\n"
	"L19\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L20\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L20\n"
	"\tBT L21\n"
	"\tSR\n"
	"\tBF L22\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tOUT\n"
	"L22\n"
	"\tBT L21\n"
	"\tTST '.ID'\n"
	"\tBF L23\n"
	"\tCL 'ID'\n"
	"\tOUT\n"
	"L23\n"
	"\tBT L21\n"
	"\tTST '.NUMBER'\n"
	"\tBF L24\n"
	"\tCL 'NUM'\n"
	"\tOUT\n"
	"L24\n"
	"\tBT L21\n"
	"\tTST '.STRING'\n"
	"\tBF L25\n"
	"\tCL 'SR'\n"
	"\tOUT\n"
	"L25\n"
	"\tBT L21\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L21\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L27\n"
	"\tBT L21\n"
	"\tTST '$'\n"
	"\tBF L28\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L28\n"
	"L21\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L29\n"
	"\tTST '('\n"
	"\tBE\n"
	"L30\n"
	"\tCLL OUT1\n"
	"\tBT L30\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"\tBT L31\n"
	"\tTST '.LABEL'\n"
	"\tBF L32\n"
	"\tCL 'LB'\n"
	"\tOUT\n"
	"\tCLL OUT1\n"
	"\tBE\n"
	"L32\n"
	"L31\n"
	"\tBF L33\n"
	"\tCL 'OUT'\n"
	"\tOUT\n"
	"L33\n"
	"L34\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*1'\n"
	"\tBF L35\n"
	"\tCL 'GN1'\n"
	"\tOUT\n"
	"L35\n"
	"\tBT L36\n"
	"\tTST '*2'\n"
	"\tBF L37\n"
	"\tCL 'GN2'\n"
	"\tOUT\n"
	"L37\n"
	"\tBT L36\n"
	"\tTST '*'\n"
	"\tBF L38\n"
	"\tCL 'CI'\n"
	"\tOUT\n"
	"L38\n"
	"\tBT L36\n"
	"\tSR\n"
	"\tBF L39\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L39\n"
	"\tBT L36\n"
	"\tTST '#'\n"
	"\tBF L40\n"
	"\tCL 'GN'\n"
	"\tOUT\n"
	"L40\n"
	"\tBT L36\n"
	"\tTST '.NL'\n"
	"\tBF L41\n"
	"\tCL 'NL'\n"
	"\tOUT\n"
	"L41\n"
	"\tBT L36\n"
	"\tTST '.LB'\n"
	"\tBF L42\n"
	"\tCL 'LB'\n"
	"\tOUT\n"
	"L42\n"
	"\tBT L36\n"
	"\tTST '.TB'\n"
	"\tBF L43\n"
	"\tCL 'TB'\n"
	"\tOUT\n"
	"L43\n"
	"\tBT L36\n"
	"\tTST '.LM+'\n"
	"\tBF L44\n"
	"\tCL 'LMI'\n"
	"\tOUT\n"
	"L44\n"
	"\tBT L36\n"
	"\tTST '.LM-'\n"
	"\tBF L45\n"
	"\tCL 'LMD'\n"
	"\tOUT\n"
	"L45\n"
	"L36\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c06. reject old output, c[i08,c05]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tOUT\n"
	"L2\n"
	"\tCLL ST\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tCL 'END'\n"
	"\tOUT\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L4\n"
	"\tLB\n"
	"\tCI\n"
	"\tOUT\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tCL 'R'\n"
	"\tOUT\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '/'\n"
	"\tBF L8\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L8\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L6\n"
	"L10\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L11\n"
	"\tCL 'BF '\n"
	"\tGN1\n"
	"\tOUT\n"
	"L11\n"
	"\tBT L12\n"
	"\tCLL OUTPUT\n"
	"\tBF L13\n"
	"L13\n"
	"L12\n"
	"\tBF L14\n"
	"L15\n"
	"\tCLL EX3\n"
	"\tBF L16\n"
	"\tCL 'BE'\n"
	"\tOUT\n"
	"L16\n"
	"\tBT L17\n"
	"\tCLL OUTPUT\n"
	"\tBF L18\n"
	"L18\n"
	"L17\n"
	"\tBT L15\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"L14\n"
	"L19\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L20\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L20\n"
	"\tBT L21\n"
	"\tSR\n"
	"\tBF L22\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tOUT\n"
	"L22\n"
	"\tBT L21\n"
	"\tTST '.ID'\n"
	"\tBF L23\n"
	"\tCL 'ID'\n"
	"\tOUT\n"
	"L23\n"
	"\tBT L21\n"
	"\tTST '.NUMBER'\n"
	"\tBF L24\n"
	"\tCL 'NUM'\n"
	"\tOUT\n"
	"L24\n"
	"\tBT L21\n"
	"\tTST '.STRING'\n"
	"\tBF L25\n"
	"\tCL 'SR'\n"
	"\tOUT\n"
	"L25\n"
	"\tBT L21\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L21\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L27\n"
	"\tBT L21\n"
	"\tTST '$'\n"
	"\tBF L28\n"
	"\tLB\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL 'BT '\n"
	"\tGN1\n"
	"\tOUT\n"
	"\tCL 'SET'\n"
	"\tOUT\n"
	"L28\n"
	"L21\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L29\n"
	"\tTST '('\n"
	"\tBE\n"
	"L30\n"
	"\tCLL OUT1\n"
	"\tBT L30\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"L31\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L32\n"
	"\tCL 'CI'\n"
	"\tOUT\n"
	"L32\n"
	"\tBT L33\n"
	"\tSR\n"
	"\tBF L34\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tOUT\n"
	"L34\n"
	"\tBT L33\n"
	"\tTST '#'\n"
	"\tBF L35\n"
	"\tCL 'GN'\n"
	"\tOUT\n"
	"L35\n"
	"\tBT L33\n"
	"\tTST '.NL'\n"
	"\tBF L36\n"
	"\tCL 'NL'\n"
	"\tOUT\n"
	"L36\n"
	"\tBT L33\n"
	"\tTST '.LB'\n"
	"\tBF L37\n"
	"\tCL 'LB'\n"
	"\tOUT\n"
	"L37\n"
	"\tBT L33\n"
	"\tTST '.TB'\n"
	"\tBF L38\n"
	"\tCL 'TB'\n"
	"\tOUT\n"
	"L38\n"
	"\tBT L33\n"
	"\tTST '.LM+'\n"
	"\tBF L39\n"
	"\tCL 'LMI'\n"
	"\tOUT\n"
	"L39\n"
	"\tBT L33\n"
	"\tTST '.LM-'\n"
	"\tBF L40\n"
	"\tCL 'LMD'\n"
	"\tOUT\n"
	"L40\n"
	"L33\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c07. use new output, c[i09,c06], m[i09,c07]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tLB\n"
	"\tTB\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tNL\n"
	"L2\n"
	"\tCLL ST\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'END'\n"
	"\tNL\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L4\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '/'\n"
	"\tBF L8\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L8\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L6\n"
	"L10\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L11\n"
	"\tTB\n"
	"\tCL 'BF L'\n"
	"\tGN\n"
	"\tNL\n"
	"L11\n"
	"\tBT L12\n"
	"\tCLL OUTPUT\n"
	"\tBF L13\n"
	"L13\n"
	"L12\n"
	"\tBF L14\n"
	"L15\n"
	"\tCLL EX3\n"
	"\tBF L16\n"
	"\tTB\n"
	"\tCL 'BE'\n"
	"\tNL\n"
	"L16\n"
	"\tBT L17\n"
	"\tCLL OUTPUT\n"
	"\tBF L18\n"
	"L18\n"
	"L17\n"
	"\tBT L15\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L14\n"
	"L19\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L20\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L20\n"
	"\tBT L21\n"
	"\tSR\n"
	"\tBF L22\n"
	"\tTB\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tNL\n"
	"L22\n"
	"\tBT L21\n"
	"\tTST '.ID'\n"
	"\tBF L23\n"
	"\tTB\n"
	"\tCL 'ID'\n"
	"\tNL\n"
	"L23\n"
	"\tBT L21\n"
	"\tTST '.NUMBER'\n"
	"\tBF L24\n"
	"\tTB\n"
	"\tCL 'NUM'\n"
	"\tNL\n"
	"L24\n"
	"\tBT L21\n"
	"\tTST '.STRING'\n"
	"\tBF L25\n"
	"\tTB\n"
	"\tCL 'SR'\n"
	"\tNL\n"
	"L25\n"
	"\tBT L21\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L21\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L27\n"
	"\tBT L21\n"
	"\tTST '$'\n"
	"\tBF L28\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L28\n"
	"L21\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L29\n"
	"\tTST '('\n"
	"\tBE\n"
	"L30\n"
	"\tCLL OUT1\n"
	"\tBT L30\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"L31\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L32\n"
	"\tTB\n"
	"\tCL 'CI'\n"
	"\tNL\n"
	"L32\n"
	"\tBT L33\n"
	"\tSR\n"
	"\tBF L34\n"
	"\tTB\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tNL\n"
	"L34\n"
	"\tBT L33\n"
	"\tTST '#'\n"
	"\tBF L35\n"
	"\tTB\n"
	"\tCL 'GN'\n"
	"\tNL\n"
	"L35\n"
	"\tBT L33\n"
	"\tTST '.NL'\n"
	"\tBF L36\n"
	"\tTB\n"
	"\tCL 'NL'\n"
	"\tNL\n"
	"L36\n"
	"\tBT L33\n"
	"\tTST '.LB'\n"
	"\tBF L37\n"
	"\tTB\n"
	"\tCL 'LB'\n"
	"\tNL\n"
	"L37\n"
	"\tBT L33\n"
	"\tTST '.TB'\n"
	"\tBF L38\n"
	"\tTB\n"
	"\tCL 'TB'\n"
	"\tNL\n"
	"L38\n"
	"\tBT L33\n"
	"\tTST '.LM+'\n"
	"\tBF L39\n"
	"\tTB\n"
	"\tCL 'LMI'\n"
	"\tNL\n"
	"L39\n"
	"\tBT L33\n"
	"\tTST '.LM-'\n"
	"\tBF L40\n"
	"\tTB\n"
	"\tCL 'LMD'\n"
	"\tNL\n"
	"L40\n"
	"L33\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c08. compile to js functions, c[i10,c07]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL '// '\n"
	"\tCI\n"
	"\tCL ' compiler'\n"
	"\tNL\n"
	"\tCL 'function compiler (input) {'\n"
	"\tLMI\n"
	"\tNL\n"
	"\tCL 'inbuf = input ;'\n"
	"\tNL\n"
	"\tCL 'inp = 0 ;'\n"
	"\tNL\n"
	"\tCL 'outbuf = \"\" ;'\n"
	"\tNL\n"
	"\tCL 'margin = 0 ;'\n"
	"\tNL\n"
	"\tCL 'gnlabel = 1 ;'\n"
	"\tNL\n"
	"\tCL 'rule'\n"
	"\tCI\n"
	"\tCL '() ;'\n"
	"\tNL\n"
	"\tCL 'return outbuf ;'\n"
	"\tNL\n"
	"\tLMD\n"
	"\tCL '} ;'\n"
	"\tNL\n"
	"\tNL\n"
	"L2\n"
	"\tCLL ST\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"L1\n"
	"L3\n"
	"\tR\n"
	"ST\n"
	"\tID\n"
	"\tBF L4\n"
	"\tLB\n"
	"\tCL 'function rule'\n"
	"\tCI\n"
	"\tCL ' () {'\n"
	"\tLMI\n"
	"\tNL\n"
	"\tCL 'var rname = \"'\n"
	"\tCI\n"
	"\tCL '\" ;'\n"
	"\tNL\n"
	"\tCL 'var rlabel = 0 ;'\n"
	"\tNL\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tLMD\n"
	"\tCL '} ;'\n"
	"\tNL\n"
	"\tNL\n"
	"L4\n"
	"L5\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L6\n"
	"L7\n"
	"\tTST '/'\n"
	"\tBF L8\n"
	"\tCL 'if (!flag) {'\n"
	"\tLMI\n"
	"\tNL\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"\tLMD\n"
	"\tCL '} ;'\n"
	"\tNL\n"
	"L8\n"
	"L9\n"
	"\tBT L7\n"
	"\tSET\n"
	"\tBE\n"
	"L6\n"
	"L10\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L11\n"
	"\tCL 'if (flag) {'\n"
	"\tLMI\n"
	"\tNL\n"
	"L11\n"
	"\tBT L12\n"
	"\tCLL OUTPUT\n"
	"\tBF L13\n"
	"\tCL 'if (true) {'\n"
	"\tLMI\n"
	"\tNL\n"
	"L13\n"
	"L12\n"
	"\tBF L14\n"
	"L15\n"
	"\tCLL EX3\n"
	"\tBF L16\n"
	"\tCL 'if (!flag) runBEjsfn(rname);'\n"
	"\tNL\n"
	"L16\n"
	"\tBT L17\n"
	"\tCLL OUTPUT\n"
	"\tBF L18\n"
	"L18\n"
	"L17\n"
	"\tBT L15\n"
	"\tSET\n"
	"\tBE\n"
	"\tLMD\n"
	"\tCL '} ;'\n"
	"\tNL\n"
	"L14\n"
	"L19\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L20\n"
	"\tCL 'rule'\n"
	"\tCI\n"
	"\tCL '();'\n"
	"\tNL\n"
	"L20\n"
	"\tBT L21\n"
	"\tSR\n"
	"\tBF L22\n"
	"\tCL 'runTST('\n"
	"\tCI\n"
	"\tCL ');'\n"
	"\tNL\n"
	"L22\n"
	"\tBT L21\n"
	"\tTST '.ID'\n"
	"\tBF L23\n"
	"\tCL 'runID();'\n"
	"\tNL\n"
	"L23\n"
	"\tBT L21\n"
	"\tTST '.NUMBER'\n"
	"\tBF L24\n"
	"\tCL 'runNUM();'\n"
	"\tNL\n"
	"L24\n"
	"\tBT L21\n"
	"\tTST '.STRING'\n"
	"\tBF L25\n"
	"\tCL 'runSR();'\n"
	"\tNL\n"
	"L25\n"
	"\tBT L21\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L21\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tCL 'runSET();'\n"
	"\tNL\n"
	"L27\n"
	"\tBT L21\n"
	"\tTST '$'\n"
	"\tBF L28\n"
	"\tCL 'runSET();'\n"
	"\tNL\n"
	"\tCL 'while (flag) {'\n"
	"\tLMI\n"
	"\tNL\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tCL '};'\n"
	"\tLMD\n"
	"\tNL\n"
	"\tCL 'runSET();'\n"
	"\tNL\n"
	"L28\n"
	"L21\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L29\n"
	"\tTST '('\n"
	"\tBE\n"
	"L30\n"
	"\tCLL OUT1\n"
	"\tBT L30\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"L31\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L32\n"
	"\tCL 'runCI();'\n"
	"\tNL\n"
	"L32\n"
	"\tBT L33\n"
	"\tSR\n"
	"\tBF L34\n"
	"\tCL 'runCL('\n"
	"\tCI\n"
	"\tCL ');'\n"
	"\tNL\n"
	"L34\n"
	"\tBT L33\n"
	"\tTST '#'\n"
	"\tBF L35\n"
	"\tCL 'if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;'\n"
	"\tNL\n"
	"\tCL 'runCL(rlabel.toString());'\n"
	"\tNL\n"
	"L35\n"
	"\tBT L33\n"
	"\tTST '.NL'\n"
	"\tBF L36\n"
	"\tCL 'runextNL();'\n"
	"\tNL\n"
	"L36\n"
	"\tBT L33\n"
	"\tTST '.LB'\n"
	"\tBF L37\n"
	"\tCL 'runLB();'\n"
	"\tNL\n"
	"L37\n"
	"\tBT L33\n"
	"\tTST '.TB'\n"
	"\tBF L38\n"
	"\tCL 'runextTB();'\n"
	"\tNL\n"
	"L38\n"
	"\tBT L33\n"
	"\tTST '.LM+'\n"
	"\tBF L39\n"
	"\tCL 'runextLMI();'\n"
	"\tNL\n"
	"L39\n"
	"\tBT L33\n"
	"\tTST '.LM-'\n"
	"\tBF L40\n"
	"\tCL 'runextLMD();'\n"
	"\tNL\n"
	"L40\n"
	"L33\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c09. accept tokens, c[i11,c07]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tID\n"
	"\tBE\n"
	"\tLB\n"
	"\tTB\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tNL\n"
	"L2\n"
	"\tCLL PR\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.TOKENS'\n"
	"\tBE\n"
	"L3\n"
	"\tCLL TR\n"
	"\tBT L3\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'END'\n"
	"\tNL\n"
	"L1\n"
	"L4\n"
	"\tR\n"
	"PR\n"
	"\tID\n"
	"\tBF L5\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L5\n"
	"L6\n"
	"\tR\n"
	"TR\n"
	"\tID\n"
	"\tBF L7\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST ':'\n"
	"\tBE\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L7\n"
	"L8\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L9\n"
	"L10\n"
	"\tTST '/'\n"
	"\tBF L11\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L11\n"
	"L12\n"
	"\tBT L10\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L9\n"
	"L13\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L14\n"
	"\tTB\n"
	"\tCL 'BF L'\n"
	"\tGN\n"
	"\tNL\n"
	"L14\n"
	"\tBT L15\n"
	"\tCLL OUTPUT\n"
	"\tBF L16\n"
	"L16\n"
	"L15\n"
	"\tBF L17\n"
	"L18\n"
	"\tCLL EX3\n"
	"\tBF L19\n"
	"\tTB\n"
	"\tCL 'BE'\n"
	"\tNL\n"
	"L19\n"
	"\tBT L20\n"
	"\tCLL OUTPUT\n"
	"\tBF L21\n"
	"L21\n"
	"L20\n"
	"\tBT L18\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L17\n"
	"L22\n"
	"\tR\n"
	"EX3\n"
	"\tID\n"
	"\tBF L23\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L23\n"
	"\tBT L24\n"
	"\tSR\n"
	"\tBF L25\n"
	"\tTB\n"
	"\tCL 'TST '\n"
	"\tCI\n"
	"\tNL\n"
	"L25\n"
	"\tBT L24\n"
	"\tTST '.ID'\n"
	"\tBF L26\n"
	"\tTB\n"
	"\tCL 'ID'\n"
	"\tNL\n"
	"L26\n"
	"\tBT L24\n"
	"\tTST '.NUMBER'\n"
	"\tBF L27\n"
	"\tTB\n"
	"\tCL 'NUM'\n"
	"\tNL\n"
	"L27\n"
	"\tBT L24\n"
	"\tTST '.STRING'\n"
	"\tBF L28\n"
	"\tTB\n"
	"\tCL 'SR'\n"
	"\tNL\n"
	"L28\n"
	"\tBT L24\n"
	"\tTST '('\n"
	"\tBF L29\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L29\n"
	"\tBT L24\n"
	"\tTST '.EMPTY'\n"
	"\tBF L30\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L30\n"
	"\tBT L24\n"
	"\tTST '$'\n"
	"\tBF L31\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L31\n"
	"L24\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L32\n"
	"\tTST '('\n"
	"\tBE\n"
	"L33\n"
	"\tCLL OUT1\n"
	"\tBT L33\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L32\n"
	"L34\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L35\n"
	"\tTB\n"
	"\tCL 'CI'\n"
	"\tNL\n"
	"L35\n"
	"\tBT L36\n"
	"\tSR\n"
	"\tBF L37\n"
	"\tTB\n"
	"\tCL 'CL '\n"
	"\tCI\n"
	"\tNL\n"
	"L37\n"
	"\tBT L36\n"
	"\tNUM\n"
	"\tBF L38\n"
	"\tTB\n"
	"\tCL 'CC '\n"
	"\tCI\n"
	"\tNL\n"
	"L38\n"
	"\tBT L36\n"
	"\tTST '#'\n"
	"\tBF L39\n"
	"\tTB\n"
	"\tCL 'GN'\n"
	"\tNL\n"
	"L39\n"
	"\tBT L36\n"
	"\tTST '.NL'\n"
	"\tBF L40\n"
	"\tTB\n"
	"\tCL 'NL'\n"
	"\tNL\n"
	"L40\n"
	"\tBT L36\n"
	"\tTST '.LB'\n"
	"\tBF L41\n"
	"\tTB\n"
	"\tCL 'LB'\n"
	"\tNL\n"
	"L41\n"
	"\tBT L36\n"
	"\tTST '.TB'\n"
	"\tBF L42\n"
	"\tTB\n"
	"\tCL 'TB'\n"
	"\tNL\n"
	"L42\n"
	"\tBT L36\n"
	"\tTST '.LM+'\n"
	"\tBF L43\n"
	"\tTB\n"
	"\tCL 'LMI'\n"
	"\tNL\n"
	"L43\n"
	"\tBT L36\n"
	"\tTST '.LM-'\n"
	"\tBF L44\n"
	"\tTB\n"
	"\tCL 'LMD'\n"
	"\tNL\n"
	"L44\n"
	"L36\n"
	"\tR\n"
	"TX1\n"
	"\tCLL TX2\n"
	"\tBF L45\n"
	"L46\n"
	"\tTST '/'\n"
	"\tBF L47\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX2\n"
	"\tBE\n"
	"L47\n"
	"L48\n"
	"\tBT L46\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L45\n"
	"L49\n"
	"\tR\n"
	"TX2\n"
	"\tCLL TX3\n"
	"\tBF L50\n"
	"\tTB\n"
	"\tCL 'BF T'\n"
	"\tGN\n"
	"\tNL\n"
	"L51\n"
	"\tCLL TX3\n"
	"\tBF L52\n"
	"\tTB\n"
	"\tCL 'RF'\n"
	"\tNL\n"
	"L52\n"
	"L53\n"
	"\tBT L51\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L50\n"
	"L54\n"
	"\tR\n"
	"TX3\n"
	"\tTST '.TOKEN'\n"
	"\tBF L55\n"
	"\tTB\n"
	"\tCL 'TFT'\n"
	"\tNL\n"
	"L55\n"
	"\tBT L56\n"
	"\tTST '.DELTOK'\n"
	"\tBF L57\n"
	"\tTB\n"
	"\tCL 'TFF'\n"
	"\tNL\n"
	"L57\n"
	"\tBT L56\n"
	"\tTST '$'\n"
	"\tBF L58\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"L58\n"
	"L56\n"
	"\tBF L59\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L59\n"
	"\tBT L60\n"
	"\tTST '.ANYBUT('\n"
	"\tBF L61\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'NOT'\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L61\n"
	"\tBT L60\n"
	"\tTST '.ANY('\n"
	"\tBF L62\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L62\n"
	"\tBT L60\n"
	"\tID\n"
	"\tBF L63\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L63\n"
	"\tBT L60\n"
	"\tTST '('\n"
	"\tBF L64\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L64\n"
	"L60\n"
	"\tR\n"
	"CX1\n"
	"\tCLL CX2\n"
	"\tBF L65\n"
	"L66\n"
	"\tTST '!'\n"
	"\tBF L67\n"
	"\tTB\n"
	"\tCL 'BT C'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX2\n"
	"\tBE\n"
	"L67\n"
	"L68\n"
	"\tBT L66\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'C'\n"
	"\tGN\n"
	"\tNL\n"
	"L65\n"
	"L69\n"
	"\tR\n"
	"CX2\n"
	"\tCLL CX3\n"
	"\tBF L70\n"
	"\tTST ':'\n"
	"\tBF L71\n"
	"\tTB\n"
	"\tCL 'CGE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'BF D'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'CLE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tLB\n"
	"\tCL 'D'\n"
	"\tGN\n"
	"\tNL\n"
	"L71\n"
	"\tBT L72\n"
	"\tSET\n"
	"\tBF L73\n"
	"\tTB\n"
	"\tCL 'CE '\n"
	"\tCI\n"
	"\tNL\n"
	"L73\n"
	"L72\n"
	"\tBE\n"
	"L70\n"
	"L74\n"
	"\tR\n"
	"CX3\n"
	"\tNUM\n"
	"\tBF L75\n"
	"L75\n"
	"L76\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c10. use tokens, c[i12,c09], m[i12,c10]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tCLL ID\n"
	"\tBE\n"
	"\tLB\n"
	"\tTB\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tNL\n"
	"L2\n"
	"\tCLL PR\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.TOKENS'\n"
	"\tBE\n"
	"L3\n"
	"\tCLL TR\n"
	"\tBT L3\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'END'\n"
	"\tNL\n"
	"L1\n"
	"L4\n"
	"\tR\n"
	"PR\n"
	"\tCLL ID\n"
	"\tBF L5\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L5\n"
	"L6\n"
	"\tR\n"
	"TR\n"
	"\tCLL ID\n"
	"\tBF L7\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST ':'\n"
	"\tBE\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L7\n"
	"L8\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L9\n"
	"L10\n"
	"\tTST '/'\n"
	"\tBF L11\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L11\n"
	"L12\n"
	"\tBT L10\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L9\n"
	"L13\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L14\n"
	"\tTB\n"
	"\tCL 'BF L'\n"
	"\tGN\n"
	"\tNL\n"
	"L14\n"
	"\tBT L15\n"
	"\tCLL OUTPUT\n"
	"\tBF L16\n"
	"L16\n"
	"L15\n"
	"\tBF L17\n"
	"L18\n"
	"\tCLL EX3\n"
	"\tBF L19\n"
	"\tTB\n"
	"\tCL 'BE'\n"
	"\tNL\n"
	"L19\n"
	"\tBT L20\n"
	"\tCLL OUTPUT\n"
	"\tBF L21\n"
	"L21\n"
	"L20\n"
	"\tBT L18\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L17\n"
	"L22\n"
	"\tR\n"
	"EX3\n"
	"\tCLL ID\n"
	"\tBF L23\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L23\n"
	"\tBT L24\n"
	"\tCLL STRING\n"
	"\tBF L25\n"
	"\tTB\n"
	"\tCL 'TST '\n"
	"\tCC 39\n"
	"\tCI\n"
	"\tCC 39\n"
	"\tNL\n"
	"L25\n"
	"\tBT L24\n"
	"\tTST '('\n"
	"\tBF L26\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L26\n"
	"\tBT L24\n"
	"\tTST '.EMPTY'\n"
	"\tBF L27\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L27\n"
	"\tBT L24\n"
	"\tTST '.LITCHR'\n"
	"\tBF L28\n"
	"\tTB\n"
	"\tCL 'LCH'\n"
	"\tNL\n"
	"L28\n"
	"\tBT L24\n"
	"\tTST '$'\n"
	"\tBF L29\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L29\n"
	"L24\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L30\n"
	"\tTST '('\n"
	"\tBE\n"
	"L31\n"
	"\tCLL OUT1\n"
	"\tBT L31\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L30\n"
	"L32\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L33\n"
	"\tTB\n"
	"\tCL 'CI'\n"
	"\tNL\n"
	"L33\n"
	"\tBT L34\n"
	"\tCLL STRING\n"
	"\tBF L35\n"
	"\tTB\n"
	"\tCL 'CL '\n"
	"\tCC 39\n"
	"\tCI\n"
	"\tCC 39\n"
	"\tNL\n"
	"L35\n"
	"\tBT L34\n"
	"\tCLL NUMBER\n"
	"\tBF L36\n"
	"\tTB\n"
	"\tCL 'CC '\n"
	"\tCI\n"
	"\tNL\n"
	"L36\n"
	"\tBT L34\n"
	"\tTST '#'\n"
	"\tBF L37\n"
	"\tTB\n"
	"\tCL 'GN'\n"
	"\tNL\n"
	"L37\n"
	"\tBT L34\n"
	"\tTST '.NL'\n"
	"\tBF L38\n"
	"\tTB\n"
	"\tCL 'NL'\n"
	"\tNL\n"
	"L38\n"
	"\tBT L34\n"
	"\tTST '.LB'\n"
	"\tBF L39\n"
	"\tTB\n"
	"\tCL 'LB'\n"
	"\tNL\n"
	"L39\n"
	"\tBT L34\n"
	"\tTST '.TB'\n"
	"\tBF L40\n"
	"\tTB\n"
	"\tCL 'TB'\n"
	"\tNL\n"
	"L40\n"
	"\tBT L34\n"
	"\tTST '.LM+'\n"
	"\tBF L41\n"
	"\tTB\n"
	"\tCL 'LMI'\n"
	"\tNL\n"
	"L41\n"
	"\tBT L34\n"
	"\tTST '.LM-'\n"
	"\tBF L42\n"
	"\tTB\n"
	"\tCL 'LMD'\n"
	"\tNL\n"
	"L42\n"
	"L34\n"
	"\tR\n"
	"TX1\n"
	"\tCLL TX2\n"
	"\tBF L43\n"
	"L44\n"
	"\tTST '/'\n"
	"\tBF L45\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX2\n"
	"\tBE\n"
	"L45\n"
	"L46\n"
	"\tBT L44\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L43\n"
	"L47\n"
	"\tR\n"
	"TX2\n"
	"\tCLL TX3\n"
	"\tBF L48\n"
	"\tTB\n"
	"\tCL 'BF T'\n"
	"\tGN\n"
	"\tNL\n"
	"L49\n"
	"\tCLL TX3\n"
	"\tBF L50\n"
	"\tTB\n"
	"\tCL 'RF'\n"
	"\tNL\n"
	"L50\n"
	"L51\n"
	"\tBT L49\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L48\n"
	"L52\n"
	"\tR\n"
	"TX3\n"
	"\tTST '.TOKEN'\n"
	"\tBF L53\n"
	"\tTB\n"
	"\tCL 'TFT'\n"
	"\tNL\n"
	"L53\n"
	"\tBT L54\n"
	"\tTST '.DELTOK'\n"
	"\tBF L55\n"
	"\tTB\n"
	"\tCL 'TFF'\n"
	"\tNL\n"
	"L55\n"
	"\tBT L54\n"
	"\tTST '$'\n"
	"\tBF L56\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"L56\n"
	"L54\n"
	"\tBF L57\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L57\n"
	"\tBT L58\n"
	"\tTST '.ANYBUT('\n"
	"\tBF L59\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'NOT'\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L59\n"
	"\tBT L58\n"
	"\tTST '.ANY('\n"
	"\tBF L60\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L60\n"
	"\tBT L58\n"
	"\tCLL ID\n"
	"\tBF L61\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L61\n"
	"\tBT L58\n"
	"\tTST '('\n"
	"\tBF L62\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L62\n"
	"L58\n"
	"\tR\n"
	"CX1\n"
	"\tCLL CX2\n"
	"\tBF L63\n"
	"L64\n"
	"\tTST '!'\n"
	"\tBF L65\n"
	"\tTB\n"
	"\tCL 'BT C'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX2\n"
	"\tBE\n"
	"L65\n"
	"L66\n"
	"\tBT L64\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'C'\n"
	"\tGN\n"
	"\tNL\n"
	"L63\n"
	"L67\n"
	"\tR\n"
	"CX2\n"
	"\tCLL CX3\n"
	"\tBF L68\n"
	"\tTST ':'\n"
	"\tBF L69\n"
	"\tTB\n"
	"\tCL 'CGE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'BF D'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'CLE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tLB\n"
	"\tCL 'D'\n"
	"\tGN\n"
	"\tNL\n"
	"L69\n"
	"\tBT L70\n"
	"\tSET\n"
	"\tBF L71\n"
	"\tTB\n"
	"\tCL 'CE '\n"
	"\tCI\n"
	"\tNL\n"
	"L71\n"
	"L70\n"
	"\tBE\n"
	"L68\n"
	"L72\n"
	"\tR\n"
	"CX3\n"
	"\tCLL NUMBER\n"
	"\tBF L73\n"
	"L73\n"
	"L74\n"
	"\tR\n"
	"PREFIX\n"
	"T75\n"
	"\tCE 32\n"
	"\tBT C76\n"
	"\tCE 9\n"
	"\tBT C76\n"
	"\tCE 13\n"
	"\tBT C76\n"
	"\tCE 10\n"
	"C76\n"
	"\tSCN\n"
	"\tBT T75\n"
	"\tSET\n"
	"\tBF T77\n"
	"T77\n"
	"T78\n"
	"\tR\n"
	"ID\n"
	"\tCLL PREFIX\n"
	"\tBF T79\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"\tCLL ALPHA\n"
	"\tRF\n"
	"T80\n"
	"\tCLL ALPHA\n"
	"\tBF T81\n"
	"T81\n"
	"\tBT T82\n"
	"\tCLL DIGIT\n"
	"\tBF T83\n"
	"T83\n"
	"T82\n"
	"\tBT T80\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T79\n"
	"T84\n"
	"\tR\n"
	"NUMBER\n"
	"\tCLL PREFIX\n"
	"\tBF T85\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"\tCLL DIGIT\n"
	"\tRF\n"
	"T86\n"
	"\tCLL DIGIT\n"
	"\tBT T86\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T85\n"
	"T87\n"
	"\tR\n"
	"STRING\n"
	"\tCLL PREFIX\n"
	"\tBF T88\n"
	"\tCE 39\n"
	"C89\n"
	"\tSCN\n"
	"\tRF\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"T90\n"
	"\tCE 13\n"
	"\tBT C91\n"
	"\tCE 10\n"
	"\tBT C91\n"
	"\tCE 39\n"
	"C91\n"
	"\tNOT\n"
	"\tSCN\n"
	"\tBT T90\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"\tCE 39\n"
	"C92\n"
	"\tSCN\n"
	"\tRF\n"
	"T88\n"
	"T93\n"
	"\tR\n"
	"ALPHA\n"
	"\tCGE 65\n"
	"\tBF D94\n"
	"\tCLE 90\n"
	"D94\n"
	"\tBT C95\n"
	"\tCGE 97\n"
	"\tBF D96\n"
	"\tCLE 122\n"
	"D96\n"
	"C95\n"
	"\tSCN\n"
	"\tBF T97\n"
	"T97\n"
	"T98\n"
	"\tR\n"
	"DIGIT\n"
	"\tCGE 48\n"
	"\tBF D99\n"
	"\tCLE 57\n"
	"D99\n"
	"C100\n"
	"\tSCN\n"
	"\tBF T101\n"
	"T101\n"
	"T102\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c11. accept comments, c[i13,c10]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tCLL ID\n"
	"\tBE\n"
	"\tLB\n"
	"\tTB\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tNL\n"
	"L2\n"
	"\tCLL PR\n"
	"\tBF L3\n"
	"L3\n"
	"\tBT L4\n"
	"\tCLL COMMENT\n"
	"\tBF L5\n"
	"L5\n"
	"L4\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.TOKENS'\n"
	"\tBE\n"
	"L6\n"
	"\tCLL TR\n"
	"\tBF L7\n"
	"L7\n"
	"\tBT L8\n"
	"\tCLL COMMENT\n"
	"\tBF L9\n"
	"L9\n"
	"L8\n"
	"\tBT L6\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'END'\n"
	"\tNL\n"
	"L1\n"
	"L10\n"
	"\tR\n"
	"PR\n"
	"\tCLL ID\n"
	"\tBF L11\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L11\n"
	"L12\n"
	"\tR\n"
	"TR\n"
	"\tCLL ID\n"
	"\tBF L13\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST ':'\n"
	"\tBE\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L13\n"
	"L14\n"
	"\tR\n"
	"COMMENT\n"
	"\tTST '['\n"
	"\tBF L15\n"
	"\tCLL CMLINE\n"
	"\tBE\n"
	"\tTST ']'\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL ';'\n"
	"\tCI\n"
	"\tNL\n"
	"L15\n"
	"L16\n"
	"\tR\n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L17\n"
	"L18\n"
	"\tTST '/'\n"
	"\tBF L19\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L19\n"
	"L20\n"
	"\tBT L18\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L17\n"
	"L21\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L22\n"
	"\tTB\n"
	"\tCL 'BF L'\n"
	"\tGN\n"
	"\tNL\n"
	"L22\n"
	"\tBT L23\n"
	"\tCLL OUTPUT\n"
	"\tBF L24\n"
	"L24\n"
	"L23\n"
	"\tBF L25\n"
	"L26\n"
	"\tCLL EX3\n"
	"\tBF L27\n"
	"\tTB\n"
	"\tCL 'BE'\n"
	"\tNL\n"
	"L27\n"
	"\tBT L28\n"
	"\tCLL OUTPUT\n"
	"\tBF L29\n"
	"L29\n"
	"L28\n"
	"\tBT L26\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L25\n"
	"L30\n"
	"\tR\n"
	"EX3\n"
	"\tCLL ID\n"
	"\tBF L31\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L31\n"
	"\tBT L32\n"
	"\tCLL STRING\n"
	"\tBF L33\n"
	"\tTB\n"
	"\tCL 'TST '\n"
	"\tCC 39\n"
	"\tCI\n"
	"\tCC 39\n"
	"\tNL\n"
	"L33\n"
	"\tBT L32\n"
	"\tTST '('\n"
	"\tBF L34\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L34\n"
	"\tBT L32\n"
	"\tTST '.EMPTY'\n"
	"\tBF L35\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L35\n"
	"\tBT L32\n"
	"\tTST '.LITCHR'\n"
	"\tBF L36\n"
	"\tTB\n"
	"\tCL 'LCH'\n"
	"\tNL\n"
	"L36\n"
	"\tBT L32\n"
	"\tTST '$'\n"
	"\tBF L37\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L37\n"
	"L32\n"
	"\tR\n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L38\n"
	"\tTST '('\n"
	"\tBE\n"
	"L39\n"
	"\tCLL OUT1\n"
	"\tBT L39\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L38\n"
	"L40\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L41\n"
	"\tTB\n"
	"\tCL 'CI'\n"
	"\tNL\n"
	"L41\n"
	"\tBT L42\n"
	"\tCLL STRING\n"
	"\tBF L43\n"
	"\tTB\n"
	"\tCL 'CL '\n"
	"\tCC 39\n"
	"\tCI\n"
	"\tCC 39\n"
	"\tNL\n"
	"L43\n"
	"\tBT L42\n"
	"\tCLL NUMBER\n"
	"\tBF L44\n"
	"\tTB\n"
	"\tCL 'CC '\n"
	"\tCI\n"
	"\tNL\n"
	"L44\n"
	"\tBT L42\n"
	"\tTST '#'\n"
	"\tBF L45\n"
	"\tTB\n"
	"\tCL 'GN'\n"
	"\tNL\n"
	"L45\n"
	"\tBT L42\n"
	"\tTST '.NL'\n"
	"\tBF L46\n"
	"\tTB\n"
	"\tCL 'NL'\n"
	"\tNL\n"
	"L46\n"
	"\tBT L42\n"
	"\tTST '.LB'\n"
	"\tBF L47\n"
	"\tTB\n"
	"\tCL 'LB'\n"
	"\tNL\n"
	"L47\n"
	"\tBT L42\n"
	"\tTST '.TB'\n"
	"\tBF L48\n"
	"\tTB\n"
	"\tCL 'TB'\n"
	"\tNL\n"
	"L48\n"
	"\tBT L42\n"
	"\tTST '.LM+'\n"
	"\tBF L49\n"
	"\tTB\n"
	"\tCL 'LMI'\n"
	"\tNL\n"
	"L49\n"
	"\tBT L42\n"
	"\tTST '.LM-'\n"
	"\tBF L50\n"
	"\tTB\n"
	"\tCL 'LMD'\n"
	"\tNL\n"
	"L50\n"
	"L42\n"
	"\tR\n"
	"TX1\n"
	"\tCLL TX2\n"
	"\tBF L51\n"
	"L52\n"
	"\tTST '/'\n"
	"\tBF L53\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX2\n"
	"\tBE\n"
	"L53\n"
	"L54\n"
	"\tBT L52\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L51\n"
	"L55\n"
	"\tR\n"
	"TX2\n"
	"\tCLL TX3\n"
	"\tBF L56\n"
	"\tTB\n"
	"\tCL 'BF T'\n"
	"\tGN\n"
	"\tNL\n"
	"L57\n"
	"\tCLL TX3\n"
	"\tBF L58\n"
	"\tTB\n"
	"\tCL 'RF'\n"
	"\tNL\n"
	"L58\n"
	"L59\n"
	"\tBT L57\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L56\n"
	"L60\n"
	"\tR\n"
	"TX3\n"
	"\tTST '.TOKEN'\n"
	"\tBF L61\n"
	"\tTB\n"
	"\tCL 'TFT'\n"
	"\tNL\n"
	"L61\n"
	"\tBT L62\n"
	"\tTST '.DELTOK'\n"
	"\tBF L63\n"
	"\tTB\n"
	"\tCL 'TFF'\n"
	"\tNL\n"
	"L63\n"
	"\tBT L62\n"
	"\tTST '$'\n"
	"\tBF L64\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"L64\n"
	"L62\n"
	"\tBF L65\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L65\n"
	"\tBT L66\n"
	"\tTST '.ANYBUT('\n"
	"\tBF L67\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'NOT'\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L67\n"
	"\tBT L66\n"
	"\tTST '.ANY('\n"
	"\tBF L68\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L68\n"
	"\tBT L66\n"
	"\tCLL ID\n"
	"\tBF L69\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L69\n"
	"\tBT L66\n"
	"\tTST '('\n"
	"\tBF L70\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L70\n"
	"L66\n"
	"\tR\n"
	"CX1\n"
	"\tCLL CX2\n"
	"\tBF L71\n"
	"L72\n"
	"\tTST '!'\n"
	"\tBF L73\n"
	"\tTB\n"
	"\tCL 'BT C'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX2\n"
	"\tBE\n"
	"L73\n"
	"L74\n"
	"\tBT L72\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'C'\n"
	"\tGN\n"
	"\tNL\n"
	"L71\n"
	"L75\n"
	"\tR\n"
	"CX2\n"
	"\tCLL CX3\n"
	"\tBF L76\n"
	"\tTST ':'\n"
	"\tBF L77\n"
	"\tTB\n"
	"\tCL 'CGE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'BF D'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'CLE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tLB\n"
	"\tCL 'D'\n"
	"\tGN\n"
	"\tNL\n"
	"L77\n"
	"\tBT L78\n"
	"\tSET\n"
	"\tBF L79\n"
	"\tTB\n"
	"\tCL 'CE '\n"
	"\tCI\n"
	"\tNL\n"
	"L79\n"
	"L78\n"
	"\tBE\n"
	"L76\n"
	"L80\n"
	"\tR\n"
	"CX3\n"
	"\tCLL NUMBER\n"
	"\tBF L81\n"
	"L81\n"
	"\tBT L82\n"
	"\tCLL SQUOTE\n"
	"\tBF L83\n"
	"\tLCH\n"
	"\tBE\n"
	"L83\n"
	"L82\n"
	"\tR\n"
	"PREFIX\n"
	"T84\n"
	"\tCE 32\n"
	"\tBT C85\n"
	"\tCE 9\n"
	"\tBT C85\n"
	"\tCE 13\n"
	"\tBT C85\n"
	"\tCE 10\n"
	"C85\n"
	"\tSCN\n"
	"\tBT T84\n"
	"\tSET\n"
	"\tBF T86\n"
	"T86\n"
	"T87\n"
	"\tR\n"
	"ID\n"
	"\tCLL PREFIX\n"
	"\tBF T88\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"\tCLL ALPHA\n"
	"\tRF\n"
	"T89\n"
	"\tCLL ALPHA\n"
	"\tBF T90\n"
	"T90\n"
	"\tBT T91\n"
	"\tCLL DIGIT\n"
	"\tBF T92\n"
	"T92\n"
	"T91\n"
	"\tBT T89\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T88\n"
	"T93\n"
	"\tR\n"
	"NUMBER\n"
	"\tCLL PREFIX\n"
	"\tBF T94\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"\tCLL DIGIT\n"
	"\tRF\n"
	"T95\n"
	"\tCLL DIGIT\n"
	"\tBT T95\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T94\n"
	"T96\n"
	"\tR\n"
	"STRING\n"
	"\tCLL PREFIX\n"
	"\tBF T97\n"
	"\tCE 39\n"
	"C98\n"
	"\tSCN\n"
	"\tRF\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"T99\n"
	"\tCE 13\n"
	"\tBT C100\n"
	"\tCE 10\n"
	"\tBT C100\n"
	"\tCE 39\n"
	"C100\n"
	"\tNOT\n"
	"\tSCN\n"
	"\tBT T99\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"\tCE 39\n"
	"C101\n"
	"\tSCN\n"
	"\tRF\n"
	"T97\n"
	"T102\n"
	"\tR\n"
	"ALPHA\n"
	"\tCGE 65\n"
	"\tBF D103\n"
	"\tCLE 90\n"
	"D103\n"
	"\tBT C104\n"
	"\tCGE 97\n"
	"\tBF D105\n"
	"\tCLE 122\n"
	"D105\n"
	"C104\n"
	"\tSCN\n"
	"\tBF T106\n"
	"T106\n"
	"T107\n"
	"\tR\n"
	"DIGIT\n"
	"\tCGE 48\n"
	"\tBF D108\n"
	"\tCLE 57\n"
	"D108\n"
	"C109\n"
	"\tSCN\n"
	"\tBF T110\n"
	"T110\n"
	"T111\n"
	"\tR\n"
	"SQUOTE\n"
	"\tCLL PREFIX\n"
	"\tBF T112\n"
	"\tCE 39\n"
	"C113\n"
	"\tSCN\n"
	"\tRF\n"
	"T112\n"
	"T114\n"
	"\tR\n"
	"CMLINE\n"
	"\tTFT\n"
	"\tSET\n"
	"\tBF T115\n"
	"T116\n"
	"\tCE 10\n"
	"\tBT C117\n"
	"\tCE 13\n"
	"\tBT C117\n"
	"\tCE 93\n"
	"C117\n"
	"\tNOT\n"
	"\tSCN\n"
	"\tBT T116\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T115\n"
	"T118\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c12. use comments, c[i14,c11], m[i14,c12]" ;
	Code[index].text =
	"\tADR PROGRAM\n"
	"; Example Metacompiler Definition \n"
	"; interpreter code version \n"
	"; James M. Neighbors \n"
	"; body of compiler definition \n"
	"PROGRAM\n"
	"\tTST '.SYNTAX'\n"
	"\tBF L1\n"
	"\tCLL ID\n"
	"\tBE\n"
	"\tLB\n"
	"\tTB\n"
	"\tCL 'ADR '\n"
	"\tCI\n"
	"\tNL\n"
	"L2\n"
	"\tCLL PR\n"
	"\tBF L3\n"
	"L3\n"
	"\tBT L4\n"
	"\tCLL COMMENT\n"
	"\tBF L5\n"
	"L5\n"
	"L4\n"
	"\tBT L2\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.TOKENS'\n"
	"\tBE\n"
	"L6\n"
	"\tCLL TR\n"
	"\tBF L7\n"
	"L7\n"
	"\tBT L8\n"
	"\tCLL COMMENT\n"
	"\tBF L9\n"
	"L9\n"
	"L8\n"
	"\tBT L6\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST '.END'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'END'\n"
	"\tNL\n"
	"L1\n"
	"L10\n"
	"\tR\n"
	"; parsing rule definition \n"
	"PR\n"
	"\tCLL ID\n"
	"\tBF L11\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST '='\n"
	"\tBE\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L11\n"
	"L12\n"
	"\tR\n"
	"; token rule definition \n"
	"TR\n"
	"\tCLL ID\n"
	"\tBF L13\n"
	"\tLB\n"
	"\tCI\n"
	"\tNL\n"
	"\tTST ':'\n"
	"\tBE\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ';'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'R'\n"
	"\tNL\n"
	"L13\n"
	"L14\n"
	"\tR\n"
	"; comment definition \n"
	"COMMENT\n"
	"\tTST '['\n"
	"\tBF L15\n"
	"\tCLL CMLINE\n"
	"\tBE\n"
	"\tTST ']'\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL ';'\n"
	"\tCI\n"
	"\tNL\n"
	"L15\n"
	"L16\n"
	"\tR\n"
	"; parsing expressions \n"
	"EX1\n"
	"\tCLL EX2\n"
	"\tBF L17\n"
	"L18\n"
	"\tTST '/'\n"
	"\tBF L19\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX2\n"
	"\tBE\n"
	"L19\n"
	"L20\n"
	"\tBT L18\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L17\n"
	"L21\n"
	"\tR\n"
	"EX2\n"
	"\tCLL EX3\n"
	"\tBF L22\n"
	"\tTB\n"
	"\tCL 'BF L'\n"
	"\tGN\n"
	"\tNL\n"
	"L22\n"
	"\tBT L23\n"
	"\tCLL OUTPUT\n"
	"\tBF L24\n"
	"L24\n"
	"L23\n"
	"\tBF L25\n"
	"L26\n"
	"\tCLL EX3\n"
	"\tBF L27\n"
	"\tTB\n"
	"\tCL 'BE'\n"
	"\tNL\n"
	"L27\n"
	"\tBT L28\n"
	"\tCLL OUTPUT\n"
	"\tBF L29\n"
	"L29\n"
	"L28\n"
	"\tBT L26\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"L25\n"
	"L30\n"
	"\tR\n"
	"EX3\n"
	"\tCLL ID\n"
	"\tBF L31\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L31\n"
	"\tBT L32\n"
	"\tCLL STRING\n"
	"\tBF L33\n"
	"\tTB\n"
	"\tCL 'TST '\n"
	"\tCC 39\n"
	"\tCI\n"
	"\tCC 39\n"
	"\tNL\n"
	"L33\n"
	"\tBT L32\n"
	"\tTST '('\n"
	"\tBF L34\n"
	"\tCLL EX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L34\n"
	"\tBT L32\n"
	"\tTST '.EMPTY'\n"
	"\tBF L35\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L35\n"
	"\tBT L32\n"
	"\tTST '.LITCHR'\n"
	"\tBF L36\n"
	"\tTB\n"
	"\tCL 'LCH'\n"
	"\tNL\n"
	"L36\n"
	"\tBT L32\n"
	"\tTST '$'\n"
	"\tBF L37\n"
	"\tLB\n"
	"\tCL 'L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL EX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT L'\n"
	"\tGN\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L37\n"
	"L32\n"
	"\tR\n"
	"; output expressions \n"
	"OUTPUT\n"
	"\tTST '.OUT'\n"
	"\tBF L38\n"
	"\tTST '('\n"
	"\tBE\n"
	"L39\n"
	"\tCLL OUT1\n"
	"\tBT L39\n"
	"\tSET\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L38\n"
	"L40\n"
	"\tR\n"
	"OUT1\n"
	"\tTST '*'\n"
	"\tBF L41\n"
	"\tTB\n"
	"\tCL 'CI'\n"
	"\tNL\n"
	"L41\n"
	"\tBT L42\n"
	"\tCLL STRING\n"
	"\tBF L43\n"
	"\tTB\n"
	"\tCL 'CL '\n"
	"\tCC 39\n"
	"\tCI\n"
	"\tCC 39\n"
	"\tNL\n"
	"L43\n"
	"\tBT L42\n"
	"\tCLL NUMBER\n"
	"\tBF L44\n"
	"\tTB\n"
	"\tCL 'CC '\n"
	"\tCI\n"
	"\tNL\n"
	"L44\n"
	"\tBT L42\n"
	"\tTST '#'\n"
	"\tBF L45\n"
	"\tTB\n"
	"\tCL 'GN'\n"
	"\tNL\n"
	"L45\n"
	"\tBT L42\n"
	"\tTST '.NL'\n"
	"\tBF L46\n"
	"\tTB\n"
	"\tCL 'NL'\n"
	"\tNL\n"
	"L46\n"
	"\tBT L42\n"
	"\tTST '.LB'\n"
	"\tBF L47\n"
	"\tTB\n"
	"\tCL 'LB'\n"
	"\tNL\n"
	"L47\n"
	"\tBT L42\n"
	"\tTST '.TB'\n"
	"\tBF L48\n"
	"\tTB\n"
	"\tCL 'TB'\n"
	"\tNL\n"
	"L48\n"
	"\tBT L42\n"
	"\tTST '.LM+'\n"
	"\tBF L49\n"
	"\tTB\n"
	"\tCL 'LMI'\n"
	"\tNL\n"
	"L49\n"
	"\tBT L42\n"
	"\tTST '.LM-'\n"
	"\tBF L50\n"
	"\tTB\n"
	"\tCL 'LMD'\n"
	"\tNL\n"
	"L50\n"
	"L42\n"
	"\tR\n"
	"; token expressions \n"
	"TX1\n"
	"\tCLL TX2\n"
	"\tBF L51\n"
	"L52\n"
	"\tTST '/'\n"
	"\tBF L53\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX2\n"
	"\tBE\n"
	"L53\n"
	"L54\n"
	"\tBT L52\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L51\n"
	"L55\n"
	"\tR\n"
	"TX2\n"
	"\tCLL TX3\n"
	"\tBF L56\n"
	"\tTB\n"
	"\tCL 'BF T'\n"
	"\tGN\n"
	"\tNL\n"
	"L57\n"
	"\tCLL TX3\n"
	"\tBF L58\n"
	"\tTB\n"
	"\tCL 'RF'\n"
	"\tNL\n"
	"L58\n"
	"L59\n"
	"\tBT L57\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"L56\n"
	"L60\n"
	"\tR\n"
	"TX3\n"
	"\tTST '.TOKEN'\n"
	"\tBF L61\n"
	"\tTB\n"
	"\tCL 'TFT'\n"
	"\tNL\n"
	"L61\n"
	"\tBT L62\n"
	"\tTST '.DELTOK'\n"
	"\tBF L63\n"
	"\tTB\n"
	"\tCL 'TFF'\n"
	"\tNL\n"
	"L63\n"
	"\tBT L62\n"
	"\tTST '$'\n"
	"\tBF L64\n"
	"\tLB\n"
	"\tCL 'T'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL TX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'BT T'\n"
	"\tGN\n"
	"\tNL\n"
	"L64\n"
	"L62\n"
	"\tBF L65\n"
	"\tTB\n"
	"\tCL 'SET'\n"
	"\tNL\n"
	"L65\n"
	"\tBT L66\n"
	"\tTST '.ANYBUT('\n"
	"\tBF L67\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'NOT'\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L67\n"
	"\tBT L66\n"
	"\tTST '.ANY('\n"
	"\tBF L68\n"
	"\tCLL CX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'SCN'\n"
	"\tNL\n"
	"L68\n"
	"\tBT L66\n"
	"\tCLL ID\n"
	"\tBF L69\n"
	"\tTB\n"
	"\tCL 'CLL '\n"
	"\tCI\n"
	"\tNL\n"
	"L69\n"
	"\tBT L66\n"
	"\tTST '('\n"
	"\tBF L70\n"
	"\tCLL TX1\n"
	"\tBE\n"
	"\tTST ')'\n"
	"\tBE\n"
	"L70\n"
	"L66\n"
	"\tR\n"
	"; character expressions \n"
	"CX1\n"
	"\tCLL CX2\n"
	"\tBF L71\n"
	"L72\n"
	"\tTST '!'\n"
	"\tBF L73\n"
	"\tTB\n"
	"\tCL 'BT C'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX2\n"
	"\tBE\n"
	"L73\n"
	"L74\n"
	"\tBT L72\n"
	"\tSET\n"
	"\tBE\n"
	"\tLB\n"
	"\tCL 'C'\n"
	"\tGN\n"
	"\tNL\n"
	"L71\n"
	"L75\n"
	"\tR\n"
	"CX2\n"
	"\tCLL CX3\n"
	"\tBF L76\n"
	"\tTST ':'\n"
	"\tBF L77\n"
	"\tTB\n"
	"\tCL 'CGE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tTB\n"
	"\tCL 'BF D'\n"
	"\tGN\n"
	"\tNL\n"
	"\tCLL CX3\n"
	"\tBE\n"
	"\tTB\n"
	"\tCL 'CLE '\n"
	"\tCI\n"
	"\tNL\n"
	"\tLB\n"
	"\tCL 'D'\n"
	"\tGN\n"
	"\tNL\n"
	"L77\n"
	"\tBT L78\n"
	"\tSET\n"
	"\tBF L79\n"
	"\tTB\n"
	"\tCL 'CE '\n"
	"\tCI\n"
	"\tNL\n"
	"L79\n"
	"L78\n"
	"\tBE\n"
	"L76\n"
	"L80\n"
	"\tR\n"
	"CX3\n"
	"\tCLL NUMBER\n"
	"\tBF L81\n"
	"L81\n"
	"\tBT L82\n"
	"\tCLL SQUOTE\n"
	"\tBF L83\n"
	"\tLCH\n"
	"\tBE\n"
	"L83\n"
	"L82\n"
	"\tR\n"
	"; token definitions \n"
	"PREFIX\n"
	"T84\n"
	"\tCE 32\n"
	"\tBT C85\n"
	"\tCE 9\n"
	"\tBT C85\n"
	"\tCE 13\n"
	"\tBT C85\n"
	"\tCE 10\n"
	"C85\n"
	"\tSCN\n"
	"\tBT T84\n"
	"\tSET\n"
	"\tBF T86\n"
	"T86\n"
	"T87\n"
	"\tR\n"
	"ID\n"
	"\tCLL PREFIX\n"
	"\tBF T88\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"\tCLL ALPHA\n"
	"\tRF\n"
	"T89\n"
	"\tCLL ALPHA\n"
	"\tBF T90\n"
	"T90\n"
	"\tBT T91\n"
	"\tCLL DIGIT\n"
	"\tBF T92\n"
	"T92\n"
	"T91\n"
	"\tBT T89\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T88\n"
	"T93\n"
	"\tR\n"
	"NUMBER\n"
	"\tCLL PREFIX\n"
	"\tBF T94\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"\tCLL DIGIT\n"
	"\tRF\n"
	"T95\n"
	"\tCLL DIGIT\n"
	"\tBT T95\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T94\n"
	"T96\n"
	"\tR\n"
	"STRING\n"
	"\tCLL PREFIX\n"
	"\tBF T97\n"
	"\tCE 39\n"
	"C98\n"
	"\tSCN\n"
	"\tRF\n"
	"\tTFT\n"
	"\tSET\n"
	"\tRF\n"
	"T99\n"
	"\tCE 13\n"
	"\tBT C100\n"
	"\tCE 10\n"
	"\tBT C100\n"
	"\tCE 39\n"
	"C100\n"
	"\tNOT\n"
	"\tSCN\n"
	"\tBT T99\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"\tCE 39\n"
	"C101\n"
	"\tSCN\n"
	"\tRF\n"
	"T97\n"
	"T102\n"
	"\tR\n"
	"ALPHA\n"
	"\tCGE 65\n"
	"\tBF D103\n"
	"\tCLE 90\n"
	"D103\n"
	"\tBT C104\n"
	"\tCGE 97\n"
	"\tBF D105\n"
	"\tCLE 122\n"
	"D105\n"
	"C104\n"
	"\tSCN\n"
	"\tBF T106\n"
	"T106\n"
	"T107\n"
	"\tR\n"
	"DIGIT\n"
	"\tCGE 48\n"
	"\tBF D108\n"
	"\tCLE 57\n"
	"D108\n"
	"C109\n"
	"\tSCN\n"
	"\tBF T110\n"
	"T110\n"
	"T111\n"
	"\tR\n"
	"SQUOTE\n"
	"\tCLL PREFIX\n"
	"\tBF T112\n"
	"\tCE 39\n"
	"C113\n"
	"\tSCN\n"
	"\tRF\n"
	"T112\n"
	"T114\n"
	"\tR\n"
	"CMLINE\n"
	"\tTFT\n"
	"\tSET\n"
	"\tBF T115\n"
	"T116\n"
	"\tCE 10\n"
	"\tBT C117\n"
	"\tCE 13\n"
	"\tBT C117\n"
	"\tCE 93\n"
	"C117\n"
	"\tNOT\n"
	"\tSCN\n"
	"\tBT T116\n"
	"\tSET\n"
	"\tRF\n"
	"\tTFF\n"
	"\tSET\n"
	"\tRF\n"
	"T115\n"
	"T118\n"
	"\tR\n"
	"\tEND\n";

	index++ ;
	Code[index].menu = "c00a. demo, compiled assignments c[i01a,c01bjs] " ;
	Code[index].text =
	"\taddress fern\n"
	"\tliteral 5\n"
	"\tliteral 6\n"
	"\tadd\n"
	"\tstore\n"
	"\taddress ace\n"
	"\tload fern\n"
	"\tliteral 5\n"
	"\tmpy\n"
	"\tstore\n"
	"\taddress waldo\n"
	"\tload fern\n"
	"\tload alpha\n"
	"\tload beta\n"
	"\tminus\n"
	"\tload gamma\n"
	"\texp\n"
	"\tdiv\n"
	"\tadd\n"
	"\tstore\n"
	"\taddress fern\n"
	"\tliteral 5\n"
	"\tliteral 6\n"
	"\tle\n"
	"\tstore\n"
	"\taddress ace\n"
	"\tload fern\n"
	"\tliteral 5\n"
	"\tmpy\n"
	"\tload bob\n"
	"\tge\n"
	"\tstore\n"
	"\taddress waldo\n"
	"\tload fern\n"
	"\tload alpha\n"
	"\tshl\n"
	"\tload beta\n"
	"\tload gamma\n"
	"\tshr\n"
	"\tle\n"
	"\tstore\n";


	*return_count = index;

}




// ===========================================================================================================================

/// Fill an array of meta_compiler_workshop_sources with the string constants of Input texts for the meta compiler workshop
/// The array must be large enough to accommodate the number Text entries
///
void get_meta_compiler_workshop_sources_for_Input(meta_compiler_workshop_sources *Input, int *return_count) 
{
	int index;

	index = 0;


	Input[index].menu = "i01. demo, AEXP example assignments" ;
	Input[index].text =
	"fern:=5+6;\n"
	"ace:=fern*5;\n"
	"waldo:=fern+alpha/-beta^gamma;\n";

	index++ ;
	Input[index].menu = "i02. demo, AEXP example assignment compiler" ;
	Input[index].text =
	".SYNTAX AEXP\n"
	"\n"
	"AEXP = AS $AS .,\n"
	"AS = .ID .OUT('address ' *) ':=' EX1 .OUT('store') ';' .,\n"
	"EX1 = EX2 $('+' EX2 .OUT('add') /\n"
	"            '-' EX2 .OUT('sub') ) .,\n"
	"EX2 = EX3 $('*' EX3 .OUT('mpy') /\n"
	"            '/' EX3 .OUT('div') ) .,\n"
	"EX3 = EX4 $('^' EX3 .OUT('exp')) .,\n"
	"EX4 = '+' EX5 / '-' EX5 .OUT('minus') / EX5 .,\n"
	"EX5 = .ID  .OUT('load ' *) /\n"
	"      .NUMBER .OUT('literal ' *) /\n"
	"      '(' EX1 ')' .,\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i03. Meta II syntax (paper fig. 5)" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"OUT1 = '*1' .OUT('GN1') / '*2' .OUT('GN2') /\n"
	"'*' .OUT('CI') / .STRING .OUT('CL '*).,\n"
	"\n"
	"OUTPUT = ('.OUT' '('\n"
	"$OUT1 ')' / '.LABEL' .OUT('LB') OUT1) .OUT('OUT') .,\n"
	"\n"
	"EX3 = .ID .OUT('CLL '*) / .STRING\n"
	".OUT('TST '*) / '.ID' .OUT('ID') /\n"
	"'.NUMBER' .OUT('NUM') /\n"
	"'.STRING' .OUT('SR') / '(' EX1 ')' /\n"
	"'.EMPTY' .OUT('SET') /\n"
	"'$' .LABEL *1 EX3\n"
	".OUT('BT ' *1) .OUT('SET').,\n"
	"\n"
	"EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\n"
	"$(EX3 .OUT('BE') / OUTPUT)\n"
	".LABEL *1 .,\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\n"
	".LABEL *1 .,\n"
	"\n"
	"ST = .ID .LABEL * '=' EX1\n"
	"'.,' .OUT('R').,\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\n"
	"$ ST '.END' .OUT('END').,\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i04. Meta II syntax (i03 reordered)" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\n"
	"          $ ST\n"
	"          '.END' .OUT('END') .,\n"
	"\n"
	"ST = .ID .LABEL * '=' EX1 '.,' .OUT('R') .,\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\n"
	"      .LABEL *1 .,\n"
	"\n"
	"EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\n"
	"      $(EX3 .OUT('BE') / OUTPUT)\n"
	"      .LABEL *1 .,\n"
	"\n"
	"EX3 = .ID       .OUT('CLL '*) /\n"
	"      .STRING   .OUT('TST '*) /\n"
	"      '.ID'     .OUT('ID')    /\n"
	"      '.NUMBER' .OUT('NUM')   /\n"
	"      '.STRING' .OUT('SR')    /\n"
	"      '(' EX1 ')'             /\n"
	"      '.EMPTY'  .OUT('SET')   /\n"
	"      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') .,\n"
	"\n"
	"OUTPUT = ('.OUT' '('$OUT1 ')' /\n"
	"          '.LABEL' .OUT('LB') OUT1)\n"
	"         .OUT('OUT') .,\n"
	"\n"
	"OUT1 = '*1'    .OUT('GN1')  /\n"
	"       '*2'    .OUT('GN2')  /\n"
	"       '*'     .OUT('CI')   /\n"
	"       .STRING .OUT('CL '*) .,\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i05. add semicolon line end" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\n"
	"          $ ST\n"
	"          '.END' .OUT('END') .,\n"
	"\n"
	"ST = .ID .LABEL * '=' EX1 ';' .OUT('R') .,\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\n"
	"      .LABEL *1 .,\n"
	"\n"
	"EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\n"
	"      $(EX3 .OUT('BE') / OUTPUT)\n"
	"      .LABEL *1 .,\n"
	"\n"
	"EX3 = .ID       .OUT('CLL '*) /\n"
	"      .STRING   .OUT('TST '*) /\n"
	"      '.ID'     .OUT('ID')    /\n"
	"      '.NUMBER' .OUT('NUM')   /\n"
	"      '.STRING' .OUT('SR')    /\n"
	"      '(' EX1 ')'             /\n"
	"      '.EMPTY'  .OUT('SET')   /\n"
	"      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') .,\n"
	"\n"
	"OUTPUT = ('.OUT' '('$OUT1 ')' /\n"
	"          '.LABEL' .OUT('LB') OUT1)\n"
	"         .OUT('OUT') .,\n"
	"\n"
	"OUT1 = '*1'    .OUT('GN1')  /\n"
	"       '*2'    .OUT('GN2')  /\n"
	"       '*'     .OUT('CI')   /\n"
	"       .STRING .OUT('CL '*) .,\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i06. use semicolon line end" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\n"
	"          $ ST\n"
	"          '.END' .OUT('END') ;\n"
	"\n"
	"ST = .ID .LABEL * '=' EX1 ';' .OUT('R') ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\n"
	"      .LABEL *1 ;\n"
	"\n"
	"EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\n"
	"      $(EX3 .OUT('BE') / OUTPUT)\n"
	"      .LABEL *1 ;\n"
	"\n"
	"EX3 = .ID       .OUT('CLL '*) /\n"
	"      .STRING   .OUT('TST '*) /\n"
	"      '.ID'     .OUT('ID')    /\n"
	"      '.NUMBER' .OUT('NUM')   /\n"
	"      '.STRING' .OUT('SR')    /\n"
	"      '(' EX1 ')'             /\n"
	"      '.EMPTY'  .OUT('SET')   /\n"
	"      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') ;\n"
	"\n"
	"OUTPUT = ('.OUT' '('$OUT1 ')' /\n"
	"          '.LABEL' .OUT('LB') OUT1)\n"
	"         .OUT('OUT') ;\n"
	"\n"
	"OUT1 = '*1'    .OUT('GN1')  /\n"
	"       '*2'    .OUT('GN2')  /\n"
	"       '*'     .OUT('CI')   /\n"
	"       .STRING .OUT('CL '*) ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i07. add new output control" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\n"
	"          $ ST\n"
	"          '.END' .OUT('END') ;\n"
	"\n"
	"ST = .ID .LABEL * '=' EX1 ';' .OUT('R') ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\n"
	"      .LABEL *1 ;\n"
	"\n"
	"EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\n"
	"      $(EX3 .OUT('BE') / OUTPUT)\n"
	"      .LABEL *1 ;\n"
	"\n"
	"EX3 = .ID       .OUT('CLL '*) /\n"
	"      .STRING   .OUT('TST '*) /\n"
	"      '.ID'     .OUT('ID')    /\n"
	"      '.NUMBER' .OUT('NUM')   /\n"
	"      '.STRING' .OUT('SR')    /\n"
	"      '(' EX1 ')'             /\n"
	"      '.EMPTY'  .OUT('SET')   /\n"
	"      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') ;\n"
	" \n"
	"OUTPUT = ('.OUT' '('$OUT1 ')' / \n"
	"          '.LABEL' .OUT('LB') OUT1) \n"
	"         .OUT('OUT') ;\n"
	"\n"
	"OUT1 = '*1'    .OUT('GN1')  /\n"
	"       '*2'    .OUT('GN2')  /\n"
	"       '*'     .OUT('CI')   /\n"
	"       .STRING .OUT('CL '*) /\n"
	"       '#'     .OUT('GN')   /\n"
	"       '.NL'   .OUT('NL')   /\n"
	"       '.LB'   .OUT('LB')   /\n"
	"       '.TB'   .OUT('TB')   /\n"
	"       '.LM+'  .OUT('LMI')  /\n"
	"       '.LM-'  .OUT('LMD')  ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i08. delete old output control" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT('ADR ' *)\n"
	"          $ ST \n"
	"          '.END' .OUT('END') ;\n"
	"\n"
	"ST = .ID .LABEL * '=' EX1 ';' .OUT('R') ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('BT ' *1) EX2 )\n"
	"      .LABEL *1 ;\n"
	"\n"
	"EX2 = (EX3 .OUT('BF ' *1) / OUTPUT)\n"
	"      $(EX3 .OUT('BE') / OUTPUT)\n"
	"      .LABEL *1 ;\n"
	"\n"
	"EX3 = .ID       .OUT('CLL '*) /\n"
	"      .STRING   .OUT('TST '*) /\n"
	"      '.ID'     .OUT('ID')    /\n"
	"      '.NUMBER' .OUT('NUM')   /\n"
	"      '.STRING' .OUT('SR')    /\n"
	"      '(' EX1 ')'             /\n"
	"      '.EMPTY'  .OUT('SET')   /\n"
	"      '$' .LABEL *1 EX3 .OUT('BT ' *1) .OUT('SET') ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT('CI')   / \n"
	"       .STRING .OUT('CL '*) /\n"
	"       '#'     .OUT('GN')   /\n"
	"       '.NL'   .OUT('NL')   /\n"
	"       '.LB'   .OUT('LB')   /\n"
	"       '.TB'   .OUT('TB')   /\n"
	"       '.LM+'  .OUT('LMI')  /\n"
	"       '.LM-'  .OUT('LMD')  ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i09. use new output control" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT(.LB .TB 'ADR ' * .NL)\n"
	"          $ ST\n"
	"          '.END' .OUT(.TB 'END' .NL) ;\n"
	"\n"
	"ST = .ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\n"
	"      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX3 = .ID       .OUT(.TB 'CLL '* .NL) /\n"
	"      .STRING   .OUT(.TB 'TST '* .NL) /\n"
	"      '.ID'     .OUT(.TB 'ID' .NL)    /\n"
	"      '.NUMBER' .OUT(.TB 'NUM' .NL)   /\n"
	"      '.STRING' .OUT(.TB 'SR' .NL)    /\n"
	"      '(' EX1 ')'                     /\n"
	"      '.EMPTY'  .OUT(.TB 'SET' .NL)   /\n"
	"      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT(.TB 'CI' .NL)   /\n"
	"       .STRING .OUT(.TB 'CL '* .NL) /\n"
	"       '#'     .OUT(.TB 'GN' .NL)   /\n"
	"       '.NL'   .OUT(.TB 'NL' .NL)   /\n"
	"       '.LB'   .OUT(.TB 'LB' .NL)   /\n"
	"       '.TB'   .OUT(.TB 'TB' .NL)   /\n"
	"       '.LM+'  .OUT(.TB 'LMI' .NL)  /\n"
	"       '.LM-'  .OUT(.TB 'LMD' .NL)  ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i10. convert i09 to js functions" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID\n"
	"            .OUT(.LB '// '*' compiler' .NL)\n"
	"            .OUT('function compiler (input) {' .LM+ .NL)\n"
	"            .OUT('inbuf = input ;' .NL)\n"
	"            .OUT('inp = 0 ;' .NL)\n"
	"            .OUT('outbuf = \"\" ;' .NL)\n"
	"            .OUT('margin = 0 ;' .NL)\n"
	"            .OUT('gnlabel = 1 ;' .NL)\n"
	"            .OUT('rule'*'() ;' .NL)\n"
	"            .OUT('return outbuf ;' .NL)\n"
	"            .OUT(.LM- '} ;' .NL .NL)\n"
	"          $ ST\n"
	"          '.END' ;\n"
	"\n"
	"ST = .ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"EX3 = .ID       .OUT('rule'*'();' .NL) /\n"
	"      .STRING   .OUT('runTST('*');' .NL) /\n"
	"      '.ID'     .OUT('runID();' .NL)     /\n"
	"      '.NUMBER' .OUT('runNUM();' .NL)    /\n"
	"      '.STRING' .OUT('runSR();' .NL)     /\n"
	"      '(' EX1 ')'                        /\n"
	"      '.EMPTY'  .OUT('runSET();' .NL)    /\n"
	"      '$' .OUT('runSET();' .NL)\n"
	"          .OUT('while (flag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT('};' .LM- .NL) \n"
	"          .OUT('runSET();' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT('runCI();' .NL)    /\n"
	"       .STRING .OUT('runCL('*');' .NL) /\n"
	"       '#'     .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\n"
	"               .OUT('runCL(rlabel.toString());' .NL) /\n"
	"       '.NL'   .OUT('runextNL();' .NL)    /\n"
	"       '.LB'   .OUT('runLB();' .NL)    /\n"
	"       '.TB'   .OUT('runextTB();' .NL)    /\n"
	"       '.LM+'  .OUT('runextLMI();' .NL)   /\n"
	"       '.LM-'  .OUT('runextLMD();' .NL)   ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i11. add token rules to i09" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID .OUT(.LB .TB 'ADR ' * .NL)\n"
	"          $ PR  \n"
	"          '.TOKENS'\n"
	"          $ TR\n"
	"          '.END' .OUT(.TB 'END' .NL) ;\n"
	"\n"
	"PR = .ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \n"
	"\n"
	"TR = .ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\n"
	"      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX3 = .ID       .OUT(.TB 'CLL '* .NL) /\n"
	"      .STRING   .OUT(.TB 'TST '* .NL) /\n"
	"      '.ID'     .OUT(.TB 'ID' .NL)    /\n"
	"      '.NUMBER' .OUT(.TB 'NUM' .NL)   /\n"
	"      '.STRING' .OUT(.TB 'SR' .NL)    /\n"
	"      '(' EX1 ')'                     /\n"
	"      '.EMPTY'  .OUT(.TB 'SET' .NL)   /\n"
	"      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT(.TB 'CI' .NL)   /\n"
	"       .STRING .OUT(.TB 'CL '* .NL) /\n"
	"       .NUMBER .OUT(.TB 'CC '* .NL) /\n"
	"       '#'     .OUT(.TB 'GN' .NL)   /\n"
	"       '.NL'   .OUT(.TB 'NL' .NL)   /\n"
	"       '.LB'   .OUT(.TB 'LB' .NL)   /\n"
	"       '.TB'   .OUT(.TB 'TB' .NL)   /\n"
	"       '.LM+'  .OUT(.TB 'LMI' .NL)  /\n"
	"       '.LM-'  .OUT(.TB 'LMD' .NL)  ;\n"
	"\n"
	"TX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX2 = TX3 .OUT(.TB 'BF T'# .NL)\n"
	"      $(TX3 .OUT(.TB 'RF' .NL) )\n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\n"
	"        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\n"
	"        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \n"
	"                         .OUT(.TB 'SET' .NL)               /\n"
	"      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\n"
	"      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\n"
	"      .ID                .OUT(.TB 'CLL ' * .NL)            /\n"
	"      '(' TX1 ')'                                          ;\n"
	"            \n"
	"CX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\n"
	"CX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \n"
	"               CX3\n"
	"               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\n"
	"           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\n"
	"CX3 = .NUMBER ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i11jf. add token rules to i10" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' .ID\n"
	"            .OUT(.LB '// '*' compiler' .NL)\n"
	"            .OUT('function compiler (input) {' .LM+ .NL)\n"
	"            .OUT('inbuf = input ;' .NL)\n"
	"            .OUT('inp = 0 ;' .NL)\n"
	"            .OUT('outbuf = \"\" ;' .NL)\n"
	"            .OUT('margin = 0 ;' .NL)\n"
	"            .OUT('gnlabel = 1 ;' .NL)\n"
	"            .OUT('runextTFF();' .NL)\n"
	"            .OUT('rule'*'() ;' .NL)\n"
	"            .OUT('return outbuf ;' .NL)\n"
	"            .OUT(.LM- '} ;' .NL .NL)\n"
	"          $ PR\n"
	"          '.TOKENS'\n"
	"          $ TR\n"
	"          '.END' ;\n"
	"\n"
	"PR = .ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"TR = .ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     ':' TX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"EX3 = .ID       .OUT('rule'*'();' .NL) /\n"
	"      .STRING   .OUT('runTST('*');' .NL) /\n"
	"      '.ID'     .OUT('runID();' .NL)     /\n"
	"      '.NUMBER' .OUT('runNUM();' .NL)    /\n"
	"      '.STRING' .OUT('runSR();' .NL)     /\n"
	"      '(' EX1 ')'                        /\n"
	"      '.EMPTY'  .OUT('runSET();' .NL)    /\n"
	"      '$' .OUT('runSET();' .NL)\n"
	"          .OUT('while (flag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT('};' .LM- .NL) \n"
	"          .OUT('runSET();' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT('runCI();' .NL)    /\n"
	"       .STRING .OUT('runCL('*');' .NL) /\n"
	"       .NUMBER .OUT('runextCC('*');' .NL) /\n"
	"       '#'     .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\n"
	"               .OUT('runCL(rlabel.toString());' .NL) /\n"
	"       '.NL'   .OUT('runextNL();' .NL)    /\n"
	"       '.LB'   .OUT('runLB();' .NL)    /\n"
	"       '.TB'   .OUT('runextTB();' .NL)    /\n"
	"       '.LM+'  .OUT('runextLMI();' .NL)   /\n"
	"       '.LM-'  .OUT('runextLMD();' .NL)   ;\n"
	"\n"
	"TX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"TX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \n"
	"      $(TX3 .OUT('if (!flag) return;' .NL) ) \n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\n"
	"        '.DELTOK'        .OUT('runextTFF();' .NL) /\n"
	"        '$' .OUT('runSET();' .NL)\n"
	"            .OUT('while (flag) {' .LM+ .NL)\n"
	"             TX3 \n"
	"            .OUT('};' .LM- .NL)                   )\n"
	"        .OUT('runSET();' .NL)                       /\n"
	"      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\n"
	"                         .OUT('runextSCN();' .NL)   /\n"
	"      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\n"
	"      .ID                .OUT('rule'*'();' .NL)     /\n"
	"      '(' TX1 ')'                                   ;\n"
	"            \n"
	"CX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"CX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \n"
	"               CX3\n"
	"               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\n"
	"           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\n"
	"CX3 = .NUMBER ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i12. use token rules" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\n"
	"          $ PR  \n"
	"          '.TOKENS'\n"
	"          $ TR\n"
	"          '.END' .OUT(.TB 'END' .NL) ;\n"
	"\n"
	"PR = ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \n"
	"\n"
	"TR = ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\n"
	"      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT(.TB 'CLL '* .NL)        /\n"
	"      STRING    .OUT(.TB 'TST ' 39 * 39 .NL) /\n"
	"      '(' EX1 ')'                            /\n"
	"      '.EMPTY'  .OUT(.TB 'SET' .NL)          /\n"
	"      '.LITCHR' .OUT(.TB 'LCH' .NL)          /\n"
	"      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT(.TB 'CI' .NL)          /\n"
	"       STRING  .OUT(.TB 'CL ' 39 * 39 .NL) /\n"
	"       NUMBER  .OUT(.TB 'CC '* .NL)        /\n"
	"       '#'     .OUT(.TB 'GN' .NL)          /\n"
	"       '.NL'   .OUT(.TB 'NL' .NL)          /\n"
	"       '.LB'   .OUT(.TB 'LB' .NL)          /\n"
	"       '.TB'   .OUT(.TB 'TB' .NL)          /\n"
	"       '.LM+'  .OUT(.TB 'LMI' .NL)         /\n"
	"       '.LM-'  .OUT(.TB 'LMD' .NL)         ;\n"
	"\n"
	"TX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX2 = TX3 .OUT(.TB 'BF T'# .NL)\n"
	"      $(TX3 .OUT(.TB 'RF' .NL) )\n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\n"
	"        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\n"
	"        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \n"
	"                         .OUT(.TB 'SET' .NL)               /\n"
	"      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\n"
	"      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\n"
	"      ID                 .OUT(.TB 'CLL ' * .NL)            /\n"
	"      '(' TX1 ')'                                          ;\n"
	"            \n"
	"CX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\n"
	"CX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \n"
	"               CX3\n"
	"               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\n"
	"           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\n"
	"CX3 = NUMBER ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY(65:90!97:122) ;\n"
	"DIGIT  : .ANY(48:57) ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i12jf. use token rules" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' ID\n"
	"            .OUT(.LB '// '*' compiler' .NL)\n"
	"            .OUT('function compiler (input) {' .LM+ .NL)\n"
	"            .OUT('inbuf = input ;' .NL)\n"
	"            .OUT('inp = 0 ;' .NL)\n"
	"            .OUT('outbuf = \"\" ;' .NL)\n"
	"            .OUT('margin = 0 ;' .NL)\n"
	"            .OUT('gnlabel = 1 ;' .NL)\n"
	"            .OUT('runextTFF();' .NL)\n"
	"            .OUT('rule'*'() ;' .NL)\n"
	"            .OUT('return outbuf ;' .NL)\n"
	"            .OUT(.LM- '} ;' .NL .NL)\n"
	"          $ PR\n"
	"          '.TOKENS'\n"
	"          $ TR\n"
	"          '.END' ;\n"
	"\n"
	"PR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"TR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     ':' TX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT('rule'*'();' .NL)   /\n"
	"      STRING    .OUT('runTST(' 39 * 39 ');' .NL) /\n"
	"      '(' EX1 ')'                        /\n"
	"      '.EMPTY'  .OUT('runSET();' .NL)    /\n"
	"      '.LITCHR' .OUT('runextLCH();' .NL) /\n"
	"      '$' .OUT('runSET();' .NL)\n"
	"          .OUT('while (flag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT('};' .LM- .NL) \n"
	"          .OUT('runSET();' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'    .OUT('runCI();' .NL)    /\n"
	"       STRING .OUT('runCL(' 39 * 39 ');' .NL) /\n"
	"       NUMBER .OUT('runextCC('*');' .NL) /\n"
	"       '#'    .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\n"
	"              .OUT('runCL(rlabel.toString());' .NL) /\n"
	"       '.NL'  .OUT('runextNL();' .NL)    /\n"
	"       '.LB'  .OUT('runLB();' .NL)       /\n"
	"       '.TB'  .OUT('runextTB();' .NL)    /\n"
	"       '.LM+' .OUT('runextLMI();' .NL)   /\n"
	"       '.LM-' .OUT('runextLMD();' .NL)   ;\n"
	"\n"
	"TX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"TX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \n"
	"      $(TX3 .OUT('if (!flag) return;' .NL) ) \n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\n"
	"        '.DELTOK'        .OUT('runextTFF();' .NL) /\n"
	"        '$' .OUT('runSET();' .NL)\n"
	"            .OUT('while (flag) {' .LM+ .NL)\n"
	"             TX3 \n"
	"            .OUT('};' .LM- .NL)                   )\n"
	"        .OUT('runSET();' .NL)                       /\n"
	"      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\n"
	"                         .OUT('runextSCN();' .NL)   /\n"
	"      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\n"
	"      ID                 .OUT('rule'*'();' .NL)     /\n"
	"      '(' TX1 ')'                                   ;\n"
	"            \n"
	"CX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"CX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \n"
	"               CX3\n"
	"               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\n"
	"           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\n"
	"CX3 = NUMBER ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY(65:90!97:122) ;\n"
	"DIGIT  : .ANY(48:57) ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i13. add comments and litchr to i12" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\n"
	"          $(PR / COMMENT)  \n"
	"          '.TOKENS'\n"
	"          $(TR / COMMENT)\n"
	"          '.END' .OUT(.TB 'END' .NL) ;\n"
	"\n"
	"PR = ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \n"
	"\n"
	"TR = ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\n"
	"\n"
	"COMMENT = '[' CMLINE ']' .OUT(.LB ';' * .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\n"
	"      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT(.TB 'CLL '* .NL)        /\n"
	"      STRING    .OUT(.TB 'TST ' 39 * 39 .NL) /\n"
	"      '(' EX1 ')'                            /\n"
	"      '.EMPTY'  .OUT(.TB 'SET' .NL)          /\n"
	"      '.LITCHR' .OUT(.TB 'LCH' .NL)          /\n"
	"      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT(.TB 'CI' .NL)          /\n"
	"       STRING  .OUT(.TB 'CL ' 39 * 39 .NL) /\n"
	"       NUMBER  .OUT(.TB 'CC '* .NL)        /\n"
	"       '#'     .OUT(.TB 'GN' .NL)          /\n"
	"       '.NL'   .OUT(.TB 'NL' .NL)          /\n"
	"       '.LB'   .OUT(.TB 'LB' .NL)          /\n"
	"       '.TB'   .OUT(.TB 'TB' .NL)          /\n"
	"       '.LM+'  .OUT(.TB 'LMI' .NL)         /\n"
	"       '.LM-'  .OUT(.TB 'LMD' .NL)         ;\n"
	"\n"
	"TX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX2 = TX3 .OUT(.TB 'BF T'# .NL)\n"
	"      $(TX3 .OUT(.TB 'RF' .NL) )\n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\n"
	"        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\n"
	"        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \n"
	"                         .OUT(.TB 'SET' .NL)               /\n"
	"      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\n"
	"      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\n"
	"      ID                 .OUT(.TB 'CLL ' * .NL)            /\n"
	"      '(' TX1 ')'                                          ;\n"
	"            \n"
	"CX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\n"
	"CX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \n"
	"               CX3\n"
	"               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\n"
	"           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\n"
	"CX3 = NUMBER / SQUOTE .LITCHR ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY(65:90!97:122) ;\n"
	"DIGIT  : .ANY(48:57) ;\n"
	"SQUOTE : PREFIX .ANY(39) ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!93) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i13jf. add comments and litchr to i12jf" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' ID\n"
	"            .OUT(.LB '// '*' compiler' .NL)\n"
	"            .OUT('function compiler (input) {' .LM+ .NL)\n"
	"            .OUT('inbuf = input ;' .NL)\n"
	"            .OUT('inp = 0 ;' .NL)\n"
	"            .OUT('outbuf = \"\" ;' .NL)\n"
	"            .OUT('margin = 0 ;' .NL)\n"
	"            .OUT('gnlabel = 1 ;' .NL)\n"
	"            .OUT('runextTFF();' .NL)\n"
	"            .OUT('rule'*'() ;' .NL)\n"
	"            .OUT('return outbuf ;' .NL)\n"
	"            .OUT(.LM- '} ;' .NL .NL)\n"
	"          $(PR / COMMENT)\n"
	"          '.TOKENS'\n"
	"          $(TR / COMMENT)\n"
	"          '.END' ;\n"
	"\n"
	"PR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"TR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     ':' TX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"COMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT('rule'*'();' .NL)   /\n"
	"      STRING    .OUT('runTST(' 39 * 39 ');' .NL) /\n"
	"      '(' EX1 ')'                        /\n"
	"      '.EMPTY'  .OUT('runSET();' .NL)    /\n"
	"      '.LITCHR' .OUT('runextLCH();' .NL) /\n"
	"      '$' .OUT('runSET();' .NL)\n"
	"          .OUT('while (flag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT('};' .LM- .NL) \n"
	"          .OUT('runSET();' .NL) ;\n"
	"\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'    .OUT('runCI();' .NL)    /\n"
	"       STRING .OUT('runCL(' 39 * 39 ');' .NL) /\n"
	"       NUMBER .OUT('runextCC('*');' .NL) /\n"
	"       '#'    .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\n"
	"              .OUT('runCL(rlabel.toString());' .NL) /\n"
	"       '.NL'  .OUT('runextNL();' .NL)    /\n"
	"       '.LB'  .OUT('runLB();' .NL)       /\n"
	"       '.TB'  .OUT('runextTB();' .NL)    /\n"
	"       '.LM+' .OUT('runextLMI();' .NL)   /\n"
	"       '.LM-' .OUT('runextLMD();' .NL)   ;\n"
	"\n"
	"TX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"TX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \n"
	"      $(TX3 .OUT('if (!flag) return;' .NL) ) \n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\n"
	"        '.DELTOK'        .OUT('runextTFF();' .NL) /\n"
	"        '$' .OUT('runSET();' .NL)\n"
	"            .OUT('while (flag) {' .LM+ .NL)\n"
	"             TX3 \n"
	"            .OUT('};' .LM- .NL)                   )\n"
	"        .OUT('runSET();' .NL)                       /\n"
	"      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\n"
	"                         .OUT('runextSCN();' .NL)   /\n"
	"      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\n"
	"      ID                 .OUT('rule'*'();' .NL)     /\n"
	"      '(' TX1 ')'                                   ;\n"
	"            \n"
	"CX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"CX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \n"
	"               CX3\n"
	"               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\n"
	"           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\n"
	"CX3 = NUMBER / SQUOTE .LITCHR ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY(65:90!97:122) ;\n"
	"DIGIT  : .ANY(48:57) ;\n"
	"SQUOTE : PREFIX .ANY(39) ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!93) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i14. use comments and litchr" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"[ Example Metacompiler Definition ]\n"
	"[ interpreter code version ]\n"
	"[ James M. Neighbors ]\n"
	"\n"
	"[ body of compiler definition ]\n"
	"PROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\n"
	"          $(PR / COMMENT)  \n"
	"          '.TOKENS'\n"
	"          $(TR / COMMENT)\n"
	"          '.END' .OUT(.TB 'END' .NL) ;\n"
	"\n"
	"[ parsing rule definition ]\n"
	"PR = ID .OUT(.LB * .NL) '=' EX1 ';' .OUT(.TB 'R' .NL) ; \n"
	"\n"
	"[ token rule definition ]\n"
	"TR = ID .OUT(.LB * .NL) ':' TX1 ';' .OUT(.TB 'R' .NL) ;\n"
	"\n"
	"[ comment definition ]\n"
	"COMMENT = '[' CMLINE ']' .OUT(.LB ';' * .NL) ;\n"
	"\n"
	"[ parsing expressions ]\n"
	"EX1 = EX2 $('/' .OUT(.TB 'BT L'# .NL) EX2 )\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(.TB 'BF L'# .NL) / OUTPUT)\n"
	"      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT(.TB 'CLL '* .NL)        /\n"
	"      STRING    .OUT(.TB 'TST ' 39 * 39 .NL) /\n"
	"      '(' EX1 ')'                            /\n"
	"      '.EMPTY'  .OUT(.TB 'SET' .NL)          /\n"
	"      '.LITCHR' .OUT(.TB 'LCH' .NL)          /\n"
	"      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L'# .NL) .OUT(.TB 'SET' .NL) ;\n"
	"\n"
	"[ output expressions ]\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT(.TB 'CI' .NL)          /\n"
	"       STRING  .OUT(.TB 'CL ' 39 * 39 .NL) /\n"
	"       NUMBER  .OUT(.TB 'CC '* .NL)        /\n"
	"       '#'     .OUT(.TB 'GN' .NL)          /\n"
	"       '.NL'   .OUT(.TB 'NL' .NL)          /\n"
	"       '.LB'   .OUT(.TB 'LB' .NL)          /\n"
	"       '.TB'   .OUT(.TB 'TB' .NL)          /\n"
	"       '.LM+'  .OUT(.TB 'LMI' .NL)         /\n"
	"       '.LM-'  .OUT(.TB 'LMD' .NL)         ;\n"
	"\n"
	"[ token expressions ]\n"
	"TX1 = TX2 $('/' .OUT(.TB 'BT T'# .NL) TX2) \n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX2 = TX3 .OUT(.TB 'BF T'# .NL)\n"
	"      $(TX3 .OUT(.TB 'RF' .NL) )\n"
	"      .OUT(.LB 'T'# .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT(.TB 'TFT' .NL) /\n"
	"        '.DELTOK'        .OUT(.TB 'TFF' .NL) /\n"
	"        '$' .OUT(.LB 'T'# .NL) TX3 .OUT(.TB 'BT T'# .NL) ) \n"
	"                         .OUT(.TB 'SET' .NL)               /\n"
	"      '.ANYBUT(' CX1 ')' .OUT(.TB 'NOT' .NL .TB 'SCN' .NL) /\n"
	"      '.ANY(' CX1 ')'    .OUT(.TB 'SCN' .NL)               /\n"
	"      ID                 .OUT(.TB 'CLL ' * .NL)            /\n"
	"      '(' TX1 ')'                                          ;\n"
	"\n"
	"[ character expressions ]            \n"
	"CX1 = CX2 $('!' .OUT(.TB 'BT C'# .NL) CX2) .OUT(.LB 'C'# .NL) ;\n"
	"CX2 = CX3 (':' .OUT(.TB 'CGE ' * .NL) .OUT(.TB 'BF D'# .NL) \n"
	"               CX3\n"
	"               .OUT(.TB 'CLE ' * .NL) .OUT(.LB 'D' # .NL) /\n"
	"           .EMPTY .OUT(.TB 'CE ' * .NL)                   ) ;\n"
	"CX3 = NUMBER / SQUOTE .LITCHR ;\n"
	"\n"
	"[ token definitions ]\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY('A:'Z!'a:'z) ;\n"
	"DIGIT  : .ANY('0:'9) ;\n"
	"SQUOTE : PREFIX .ANY('') ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i14jf. use comments and litchr" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"[ Example Metacompiler Definition ]\n"
	"[ javascript function version ]\n"
	"[ James M. Neighbors ]\n"
	"\n"
	"[ body of compiler definition ]\n"
	"PROGRAM = '.SYNTAX' ID\n"
	"            .OUT(.LB '// '*' compiler' .NL)\n"
	"            .OUT('function compiler (input) {' .LM+ .NL)\n"
	"            .OUT('inbuf = input ;' .NL)\n"
	"            .OUT('inp = 0 ;' .NL)\n"
	"            .OUT('outbuf = \"\" ;' .NL)\n"
	"            .OUT('margin = 0 ;' .NL)\n"
	"            .OUT('gnlabel = 1 ;' .NL)\n"
	"            .OUT('runextTFF();' .NL)\n"
	"            .OUT('rule'*'() ;' .NL)\n"
	"            .OUT('return outbuf ;' .NL)\n"
	"            .OUT(.LM- '} ;' .NL .NL)\n"
	"          $(PR / COMMENT)\n"
	"          '.TOKENS'\n"
	"          $(TR / COMMENT)\n"
	"          '.END' ;\n"
	"\n"
	"[ parsing rule definition ]\n"
	"PR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"[ token rule definition ]\n"
	"TR = ID .OUT(.LB 'function rule'*' () {' .LM+ .NL)\n"
	"     .OUT('var rname = \"'*'\" ;' .NL)\n"
	"     .OUT('var rlabel = 0 ;' .NL)\n"
	"     ':' TX1 ';'\n"
	"     .OUT(.LM- '} ;' .NL .NL) ;\n"
	"\n"
	"[ comment definition ]\n"
	"COMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\n"
	"\n"
	"[ parsing expressions ]\n"
	"EX1 = EX2 $('/' .OUT('if (!flag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (flag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      $(EX3 .OUT('if (!flag) runBEjsfn(rname);' .NL) / OUTPUT)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT('rule'*'();' .NL)   /\n"
	"      STRING    .OUT('runTST(' 39 * 39 ');' .NL) /\n"
	"      '(' EX1 ')'                        /\n"
	"      '.EMPTY'  .OUT('runSET();' .NL)    /\n"
	"      '.LITCHR' .OUT('runextLCH();' .NL) /\n"
	"      '$' .OUT('runSET();' .NL)\n"
	"          .OUT('while (flag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT('};' .LM- .NL) \n"
	"          .OUT('runSET();' .NL) ;\n"
	"\n"
	"[ output expressions ]\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'    .OUT('runCI();' .NL)    /\n"
	"       STRING .OUT('runCL(' 39 * 39 ');' .NL) /\n"
	"       NUMBER .OUT('runextCC('*');' .NL) /\n"
	"       '#'    .OUT('if (rlabel == 0) { rlabel = gnlabel; gnlabel++ ; } ;' .NL)\n"
	"              .OUT('runCL(rlabel.toString());' .NL) /\n"
	"       '.NL'  .OUT('runextNL();' .NL)    /\n"
	"       '.LB'  .OUT('runLB();' .NL)       /\n"
	"       '.TB'  .OUT('runextTB();' .NL)    /\n"
	"       '.LM+' .OUT('runextLMI();' .NL)   /\n"
	"       '.LM-' .OUT('runextLMD();' .NL)   ;\n"
	"\n"
	"[ token expressions ]\n"
	"TX1 = TX2 $('/' .OUT('if (!flag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"TX2 = TX3 .OUT('if (flag) {' .LM+ .NL) \n"
	"      $(TX3 .OUT('if (!flag) return;' .NL) ) \n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'         .OUT('runextTFT();' .NL) /\n"
	"        '.DELTOK'        .OUT('runextTFF();' .NL) /\n"
	"        '$' .OUT('runSET();' .NL)\n"
	"            .OUT('while (flag) {' .LM+ .NL)\n"
	"             TX3 \n"
	"            .OUT('};' .LM- .NL)                   )\n"
	"        .OUT('runSET();' .NL)                       /\n"
	"      '.ANYBUT(' CX1 ')' .OUT('runextNOT();' .NL)\n"
	"                         .OUT('runextSCN();' .NL)   /\n"
	"      '.ANY(' CX1 ')'    .OUT('runextSCN();' .NL)   /\n"
	"      ID                 .OUT('rule'*'();' .NL)     /\n"
	"      '(' TX1 ')'                                   ;\n"
	"            \n"
	"[ character expressions ]            \n"
	"CX1 = CX2 $('!' .OUT('if (!flag) {' .LM+ .NL) CX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"CX2 = CX3 (':' .OUT('runextCGE('*');' .NL) .OUT('if (flag) {' .LM+ .NL) \n"
	"               CX3\n"
	"               .OUT('runextCLE('*');' .NL) .OUT(.LM- '} ;' .NL) /\n"
	"           .EMPTY .OUT('runextCE('*');' .NL)                    ) ;\n"
	"CX3 = NUMBER / SQUOTE .LITCHR ;\n"
	"\n"
	"[ token definitions ]\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY('A:'Z!'a:'z) ;\n"
	"DIGIT  : .ANY('0:'9) ;\n"
	"SQUOTE : PREFIX .ANY('') ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i14js. convert i14jf to js object" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"[ Example Metacompiler Definition ]\n"
	"[ fully contained javascript object version ]\n"
	"[ James M. Neighbors ]\n"
	"\n"
	"[ body of compiler definition ]\n"
	"PROGRAM = '.SYNTAX' ID \n"
	"          .OUT(.LB '// ' * ' compiler' .NL)\n"
	"          .OUT('compiler = {' .LM+ .NL .NL)\n"
	"          PREAMBLE\n"
	"          $(PR / COMMENT)  \n"
	"          '.TOKENS'\n"
	"          $(TR / COMMENT)\n"
	"          '.END' \n"
	"          POSTAMBLE \n"
	"          .OUT(.LM- '}' .NL) ;     \n"
	"                                            \n"
	"[ object definition preamble ]\n"
	"PREAMBLE = .OUT('compile: function (input) {' .LM+ .NL)\n"
	"           .OUT('// initialize compiler variables' .NL)\n"
	"           .OUT('this.inbuf = input ;' .NL)\n"
	"           .OUT('this.initialize() ;' .NL)\n"
	"           .OUT('// call the first rule' .NL)\n"
	"           .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\n"
	"           .OUT('this.rule' * '() ;' .NL)\n"
	"           .OUT('this.ctxpop() ;' .NL)\n"
	"           .OUT('// special case handling of first rule failure' .NL)\n"
	"           .OUT('if ((!this.eflag) && (!this.pflag)) {' .LM+ .NL)\n"
	"           .OUT('this.eflag = true ;' .NL)\n"
	"           .OUT('this.erule = ' 39 * 39 ' ;' .NL)\n"
	"           .OUT('this.einput = this.inp ; } ;' .LM- .NL)\n"
	"           .OUT('return this.eflag ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL) ;\n"
	"\n"
	"\n"
	"[ runtime and object definition postamble ] \n"
	"POSTAMBLE = \n"
	"           .OUT('// runtime variables' .NL)\n"
	"           .OUT('pflag: false ,' .NL)\n"
	"           .OUT('tflag: false ,' .NL)\n"
	"           .OUT('eflag: false ,' .NL)\n"
	"           .OUT('inp: 0 ,' .NL)\n"
	"           .OUT('inbuf:  ' 39 39 ' ,' .NL)\n"
	"           .OUT('outbuf:  ' 39 39 ' ,' .NL)\n"
	"           .OUT('erule:  ' 39 39 ' ,' .NL)\n"
	"           .OUT('einput: 0 ,' .NL)\n"
	"           .OUT('token: ' 39 39 ' ,' .NL)\n"
	"           .OUT('labelcount: 0 ,' .NL)\n"
	"           .OUT('stackframesize: 3 ,' .NL)\n"
	"           .OUT('stackframe: 0 ,' .NL)\n"
	"           .OUT('stos: -1 ,' .NL)\n"
	"           .OUT('stack: [] ,' .NL .NL)\n"
	"\n"
	"           .OUT('initialize: function () {'.LM+ .NL)\n"
	"           .OUT('// initialize for another compile' .NL)\n"
	"           .OUT('this.pflag = false ;' .NL)\n"
	"           .OUT('this.tflag = false ;' .NL)\n"
	"           .OUT('this.eflag = false ;' .NL)\n"
	"           .OUT('this.inp = 0 ;' .NL)\n"
	"           .OUT('this.outbuf = ' 39 39 ' ;' .NL)\n"
	"           .OUT('this.erule = ' 39 39 ' ;' .NL)\n"
	"           .OUT('this.einput = 0 ;' .NL)\n"
	"           .OUT('this.token = ' 39 39 ' ;' .NL)\n"
	"           .OUT('this.labelcount = 1 ;' .NL)\n"
	"           .OUT('this.stackframe = -1 ;' .NL)\n"
	"           .OUT('this.stos = -1 ;' .NL)\n"
	"           .OUT('this.stack = [] ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('ctxpush: function (rulename){' .LM+ .NL)\n"
	"           .OUT('// push and initialize a new stackframe' .NL)\n"
	"           .OUT('var LM ;' .NL)  \n"
	"           .OUT('// new context inherits current context left margin' .NL)\n"
	"           .OUT('LM = 0; if (this.stackframe >= 0) LM = this.stack[this.stackframe + 2] ;' .NL)\n"
	"           .OUT('this.stos++ ;' .NL)\n"
	"           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\n"
	"           .OUT('// stackframe definition' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 0] = 0 ;        // generated label' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 1] = rulename ; // called rule name' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 2] = LM ;       // left margin' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL) \n"
	"\n"
	"           .OUT('ctxpop: function (){' .LM+ .NL)\n"
	"           .OUT('// pop and possibly deallocate old stackframe' .NL)\n"
	"           .OUT('this.stos-- ; // pop stackframe' .NL)\n"
	"           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)          \n"
	"\n"
	"           .OUT('out: function (s){' .LM+ .NL)\n"
	"           .OUT('// output string' .NL)\n"
	"           .OUT('var i ;' .NL)\n"
	"           .OUT('// if newline last output, add left margin before string' .NL)\n"
	"           .OUT('if (this.outbuf.charAt(this.outbuf.length - 1) == ' 39 92 'n' 39 ') {' .NL)\n"
	"           .OUT('  i = this.stack[this.stackframe + 2] ;' .NL)\n"
	"           .OUT('  while (i>0) { this.outbuf += ' 39 ' ' 39 ' ; i-- } ; } ;' .NL)\n"
	"           .OUT('this.outbuf += s ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('eol: function (){' .LM+ .NL)\n"
	"           .OUT('// output end of line' .NL)\n"
	"           .OUT('this.outbuf += ' 39 92 'n' 39 ' ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('test: function (s) {' .LM+ .NL)\n"
	"           .OUT('// test for a string in the input' .NL)\n"
	"           .OUT('var i ;' .NL)\n"
	"           .OUT('// delete whitespace' .NL) \n"
	"           .OUT('while ((this.inbuf.charAt(this.inp) == ' 39 ' ' 39 ')  ||' .NL)\n"
	"           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'n' 39 ') ||' .NL) \n"
	"           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'r' 39 ') ||' .NL)\n"
	"           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 't' 39 ') ) this.inp++ ;' .NL)\n"
	"           .OUT('// test string case insensitive' .NL) \n"
	"           .OUT('this.pflag = true ; i = 0 ;' .NL)\n"
	"           .OUT('while (this.pflag && (i < s.length) && ((this.inp+i) < this.inbuf.length) )' .NL)\n"
	"           .OUT('{ this.pflag = (s.charAt(i).toUpperCase() ==' .NL)\n"
	"           .OUT('                this.inbuf.charAt(this.inp+i).toUpperCase()) ;' .NL)\n"
	"           .OUT('  i++ ; } ;' .NL)\n"
	"           .OUT('this.pflag = this.pflag && (i == s.length) ;' .NL)\n"
	"           .OUT('// advance input if found' .NL) \n"
	"           .OUT('if (this.pflag) this.inp = this.inp + s.length ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('err: function () {' .LM+ .NL)\n"
	"           .OUT('// compilation error, provide error indication and context' .NL)\n"
	"           .OUT('this.eflag = true ;' .NL)\n"
	"           .OUT('this.erule = this.stack[this.stackframe + 1] ;' .NL)\n"
	"           .OUT('this.einput = this.inp ;' .NL)\n"
	"           .OUT(.LM- '}' .NL .NL) ;\n"
	"\n"
	"[ parsing rule definition ]\n"
	"PR = ID .OUT('rule'* ': function () {' .LM+ .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ,' .NL .NL) ;\n"
	"\n"
	"[ token rule definition ]\n"
	"TR = ID .OUT('rule'* ': function () {' .LM+ .NL)\n"
	"     ':' TX1 ';'\n"
	"     .OUT(.LM- '} ,' .NL .NL) ;\n"
	"\n"
	"[ comment definition ]\n"
	"COMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\n"
	"\n"
	"[ parsing expressions ]\n"
	"EX1 = EX2 $('/' .OUT('if (!this.pflag) {' .LM+ .NL) EX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (this.pflag) {' .LM+ .NL) / OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      $(EX3 .OUT('if (!this.pflag) this.err();' .NL) / OUTPUT)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"\n"
	"EX3 = ID        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\n"
	"                .OUT('this.rule' * '() ;' .NL)\n"
	"                .OUT('this.ctxpop() ;' .NL)\n"
	"                .OUT('if (this.eflag) return ;' .NL)  /\n"
	"      STRING    .OUT('this.test(' 39 * 39 ');' .NL) /\n"
	"      '(' EX1 ')'                            /\n"
	"      '.EMPTY'  .OUT('this.pflag = true ;' .NL)    /\n"
	"      '.LITCHR' .OUT('this.token = this.inbuf.charCodeAt(this.inp) ;' .NL)\n"
	"                .OUT('this.inp++ ;' .NL)  /\n"
	"      '$' .OUT('this.pflag = true ;' .NL)\n"
	"          .OUT('while (this.pflag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT(.LM- '} ;' .NL)\n"
	"          .OUT('this.pflag = true ;' .NL) ;\n"
	"\n"
	"[ output expressions ]\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT('this.out(this.token) ;' .NL)          /\n"
	"       STRING  .OUT('this.out(' 39 * 39 ') ;' .NL) /\n"
	"       NUMBER  .OUT('this.out(String.fromCharCode(' * ')) ;' .NL)        /\n"
	"       '#'     .OUT('if (this.stack[this.stackframe + 0] == 0) {' .LM+ .NL) \n"
	"               .OUT('this.stack[this.stackframe + 0] = this.labelcount ;' .NL)\n"
	"               .OUT('this.labelcount++ ; } ;' .LM- .NL) \n"
	"               .OUT('this.out(this.stack[this.stackframe + 0]) ;' .NL) /\n"
	"       '.NL'   .OUT('this.eol() ;' .NL)          /\n"
	"       '.LB'             /\n"
	"       '.TB'   .OUT('this.out(' 39 92 't' 39 ') ;' .NL)          /\n"
	"       '.LM+'  .OUT('this.stack[this.stackframe + 2] += 2 ;' .NL) /\n"
	"       '.LM-'  .OUT('this.stack[this.stackframe + 2] -= 2 ;' .NL) ;\n"
	"\n"
	"[ token expressions ]\n"
	"TX1 = TX2 $('/' .OUT('if (!this.pflag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"TX2 = TX3 .OUT('if (this.pflag) {' .LM+ .NL) \n"
	"      $(TX3 .OUT('if (!this.pflag) return;' .NL) ) \n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'  .OUT('this.tflag = true ; ' .NL)\n"
	"                  .OUT('this.token = ' 39 39 ' ;' .NL) /\n"
	"        '.DELTOK' .OUT('this.tflag = false ;' .NL) /\n"
	"        '$' .OUT('this.pflag = true ;' .NL)\n"
	"            .OUT('while (this.pflag) {' .LM+ .NL)\n"
	"             TX3 \n"
	"            .OUT(.LM- '};' .NL) )\n"
	"        .OUT('this.pflag = true ;' .NL) /\n"
	"      '.ANYBUT(' CX1 ')' .OUT('this.pflag = !this.pflag ;' .NL) \n"
	"        .OUT('if (this.pflag) {' .LM+ .NL)\n"
	"        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\n"
	"        .OUT('this.inp++ } ;' .LM- .NL) /\n"
	"      '.ANY(' CX1 ')' \n"
	"        .OUT('if (this.pflag) {' .LM+ .NL)\n"
	"        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\n"
	"        .OUT('this.inp++ } ;' .LM- .NL) /\n"
	"      ID                 \n"
	"        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\n"
	"        .OUT('this.rule' * '() ;' .NL)\n"
	"        .OUT('this.ctxpop() ;' .NL)\n"
	"        .OUT('if (this.eflag) return ;' .NL)  /\n"
	"      '(' TX1 ')'  ;\n"
	"\n"
	"[ character expressions ]            \n"
	"CX1 = .OUT('this.pflag = ' .LM+ .NL)\n"
	"      CX2 $('!' .OUT(' ||' .NL) CX2)\n"
	"      .OUT(.LM- ' ;' .NL) ;\n"
	"CX2 = CX3 (':' .OUT('((this.inbuf.charCodeAt(this.inp) >= ' * ') &&' .NL)\n"
	"               CX3\n"
	"               .OUT(' (this.inbuf.charCodeAt(this.inp) <= ' * ')  )' ) /\n"
	"           .EMPTY .OUT('(this.inbuf.charCodeAt(this.inp) == ' * ') ' )  ) ;\n"
	"CX3 = NUMBER / SQUOTE .LITCHR ;\n"
	"\n"
	"[ token definitions ]\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY('A:'Z!'a:'z) ;\n"
	"DIGIT  : .ANY('0:'9) ;\n"
	"SQUOTE : PREFIX .ANY('') ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i02a. demo, AEXP example assignment compiler" ;
	Input[index].text =
	".SYNTAX AEXP\n"
	"\n"
	"AEXP = AS $AS ;\n"
	"AS = ID .OUT(.TB 'address ' * .NL) ':=' RX1 .OUT(.TB 'store' .NL) ';' ;\n"
	"RX1 = RX2 ('='  RX2 .OUT(.TB 'eq' .NL) /\n"
	"           '<'  RX2 .OUT(.TB 'lt' .NL) /\n"
	"           '>'  RX2 .OUT(.TB 'gt' .NL) /\n"
	"           '<=' RX2 .OUT(.TB 'le' .NL) /\n"
	"           '>=' RX2 .OUT(.TB 'ge' .NL) /\n"
	"           .EMPTY) ;\n"
	"RX2 = '~' EX0 .OUT(.TB 'not' .NL) / EX0 ;\n"
	"EX0 = EX1 ('<-' EX1 .OUT(.TB 'shl' .NL) /\n"
	"           '->' EX2 .OUT(.TB 'shr' .NL) /\n"
	"           .EMPTY) ;\n"
	"EX1 = EX2 $('+' EX2 .OUT(.TB 'add' .NL) /\n"
	"            '-' EX2 .OUT(.TB 'sub' .NL) ) ;\n"
	"EX2 = EX3 $('*' EX3 .OUT(.TB 'mpy' .NL) /\n"
	"            '/' EX3 .OUT(.TB 'div' .NL) ) ;\n"
	"EX3 = EX4 $('^' EX3 .OUT(.TB 'exp' .NL)) ;\n"
	"EX4 = '+' EX5 / '-' EX5 .OUT(.TB 'minus' .NL) / EX5 ;\n"
	"EX5 = ID  .OUT(.TB 'load ' * .NL) /\n"
	"      NUMBER .OUT(.TB 'literal ' * .NL) /\n"
	"      '(' EX1 ')' ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN .ANY('A:'Z!'a:'z) $(.ANY('A:'Z!'a:'z) / .ANY('0:'9)) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN .ANY('0:'9) $.ANY('0:'9) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i01a. demo, AEXP2 backup value assignments" ;
	Input[index].text =
	"fern:=5+6;\n"
	"ace:=fern*5;\n"
	"waldo:=fern+alpha/-beta^gamma;\n"
	"fern:=5<=6;\n"
	"ace:=fern*5>=bob;\n"
	"waldo:=fern<-alpha<=beta->gamma;\n";

	index++ ;
	Input[index].menu = "i15js. js metacompiler with backup" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"[ Example Metacompiler Definition ]\n"
	"[ fully contained javascript object version with backup ]\n"
	"[ James M. Neighbors ]\n"
	"\n"
	"[ body of compiler definition ]\n"
	"PROGRAM = '.SYNTAX' ID \n"
	"          .OUT(.LB '// ' * ' compiler' .NL)\n"
	"          .OUT('compiler = {' .LM+ .NL .NL)\n"
	"          PREAMBLE\n"
	"          $(PR / COMMENT)  \n"
	"          '.TOKENS'\n"
	"          $(TR / COMMENT)\n"
	"          '.END' \n"
	"          POSTAMBLE \n"
	"          .OUT(.LM- '}' .NL) ;     \n"
	"                                            \n"
	"[ object definition preamble ]\n"
	"PREAMBLE = .OUT('compile: function (input) {' .LM+ .NL)\n"
	"           .OUT('// initialize compiler variables' .NL)\n"
	"           .OUT('this.inbuf = input ;' .NL)\n"
	"           .OUT('this.initialize() ;' .NL)\n"
	"           .OUT('// call the first rule' .NL)\n"
	"           .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\n"
	"           .OUT('this.rule' * '() ;' .NL)\n"
	"           .OUT('this.ctxpop() ;' .NL)\n"
	"           .OUT('// special case handling of first rule failure' .NL)\n"
	"           .OUT('if ((!this.eflag) && (!this.pflag)) {' .LM+ .NL)\n"
	"           .OUT('this.eflag = true ;' .NL)\n"
	"           .OUT('this.erule = ' 39 * 39 ' ;' .NL)\n"
	"           .OUT('this.einput = this.inp ; } ;' .LM- .NL)\n"
	"           .OUT('return this.eflag ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL) ;\n"
	"\n"
	"\n"
	"[ runtime and object definition postamble ] \n"
	"POSTAMBLE = \n"
	"           .OUT('// runtime variables' .NL)\n"
	"           .OUT('pflag: false ,' .NL)\n"
	"           .OUT('tflag: false ,' .NL)\n"
	"           .OUT('eflag: false ,' .NL)\n"
	"           .OUT('inp: 0 ,' .NL)\n"
	"           .OUT('inbuf:  ' 39 39 ' ,' .NL)\n"
	"           .OUT('outbuf:  ' 39 39 ' ,' .NL)\n"
	"           .OUT('erule:  ' 39 39 ' ,' .NL)\n"
	"           .OUT('einput: 0 ,' .NL)\n"
	"           .OUT('token: ' 39 39 ' ,' .NL)\n"
	"           .OUT('labelcount: 0 ,' .NL)\n"
	"           .OUT('stackframesize: 6 ,' .NL)\n"
	"           .OUT('stackframe: 0 ,' .NL)\n"
	"           .OUT('stos: -1 ,' .NL)\n"
	"           .OUT('stack: [] ,' .NL .NL)\n"
	"\n"
	"           .OUT('initialize: function () {'.LM+ .NL)\n"
	"           .OUT('// initialize for another compile' .NL)\n"
	"           .OUT('this.pflag = false ;' .NL)\n"
	"           .OUT('this.tflag = false ;' .NL)\n"
	"           .OUT('this.eflag = false ;' .NL)\n"
	"           .OUT('this.inp = 0 ;' .NL)\n"
	"           .OUT('this.outbuf = ' 39 39 ' ;' .NL)\n"
	"           .OUT('this.erule = ' 39 39 ' ;' .NL)\n"
	"           .OUT('this.einput = 0 ;' .NL)\n"
	"           .OUT('this.token = ' 39 39 ' ;' .NL)\n"
	"           .OUT('this.labelcount = 1 ;' .NL)\n"
	"           .OUT('this.stackframe = -1 ;' .NL)\n"
	"           .OUT('this.stos = -1 ;' .NL)\n"
	"           .OUT('this.stack = [] ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('ctxpush: function (rulename){' .LM+ .NL)\n"
	"           .OUT('// push and initialize a new stackframe' .NL)\n"
	"           .OUT('var LM ;' .NL)  \n"
	"           .OUT('// new context inherits current context left margin' .NL)\n"
	"           .OUT('LM = 0; if (this.stackframe >= 0) LM = this.stack[this.stackframe + 2] ;' .NL)\n"
	"           .OUT('this.stos++ ;' .NL)\n"
	"           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\n"
	"           .OUT('// stackframe definition' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 0] = 0 ;        // generated label' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 1] = rulename ; // called rule name' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 2] = LM ;       // left margin' .NL)\n"
	"           .OUT('// clear additional stackframe backtracking entries' .NL)\n"
	"           .OUT('this.bkclear() ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('ctxpop: function (){' .LM+ .NL)\n"
	"           .OUT('// pop and possibly deallocate old stackframe' .NL)\n"
	"           .OUT('this.stos-- ; // pop stackframe' .NL)\n"
	"           .OUT('this.stackframe = this.stos * this.stackframesize ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)          \n"
	"\n"
	"           .OUT('out: function (s){' .LM+ .NL)\n"
	"           .OUT('// output string' .NL)\n"
	"           .OUT('var i ;' .NL)\n"
	"           .OUT('// if newline last output, add left margin before string' .NL)\n"
	"           .OUT('if (this.outbuf.charAt(this.outbuf.length - 1) == ' 39 92 'n' 39 ') {' .NL)\n"
	"           .OUT('  i = this.stack[this.stackframe + 2] ;' .NL)\n"
	"           .OUT('  while (i>0) { this.outbuf += ' 39 ' ' 39 ' ; i-- } ; } ;' .NL)\n"
	"           .OUT('this.outbuf += s ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('eol: function (){' .LM+ .NL)\n"
	"           .OUT('// output end of line' .NL)\n"
	"           .OUT('this.outbuf += ' 39 92 'n' 39 ' ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('test: function (s) {' .LM+ .NL)\n"
	"           .OUT('// test for a string in the input' .NL)\n"
	"           .OUT('var i ;' .NL)\n"
	"           .OUT('// delete whitespace' .NL) \n"
	"           .OUT('while ((this.inbuf.charAt(this.inp) == ' 39 ' ' 39 ')  ||' .NL)\n"
	"           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'n' 39 ') ||' .NL) \n"
	"           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 'r' 39 ') ||' .NL)\n"
	"           .OUT('       (this.inbuf.charAt(this.inp) == ' 39 92 't' 39 ') ) this.inp++ ;' .NL)\n"
	"           .OUT('// test string case insensitive' .NL) \n"
	"           .OUT('this.pflag = true ; i = 0 ;' .NL)\n"
	"           .OUT('while (this.pflag && (i < s.length) && ((this.inp+i) < this.inbuf.length) )' .NL)\n"
	"           .OUT('{ this.pflag = (s.charAt(i).toUpperCase() ==' .NL)\n"
	"           .OUT('                this.inbuf.charAt(this.inp+i).toUpperCase()) ;' .NL)\n"
	"           .OUT('  i++ ; } ;' .NL)\n"
	"           .OUT('this.pflag = this.pflag && (i == s.length) ;' .NL)\n"
	"           .OUT('// advance input if found' .NL) \n"
	"           .OUT('if (this.pflag) this.inp = this.inp + s.length ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('bkerr: function () {' .LM+ .NL)\n"
	"           .OUT('// compilation error, provide error indication and context' .NL)\n"
	"           .OUT('this.eflag = true ;' .NL)\n"
	"           .OUT('this.erule = this.stack[this.stackframe + 1] ;' .NL)\n"
	"           .OUT('this.einput = this.inp ;' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('bkset: function () {' .LM+ .NL)\n"
	"           .OUT('// set backtrack context on stack' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 3] = this.inp ;           // input position' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 4] = this.outbuf.length ; // output position' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 5] = this.token ;         // current token' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('bkclear: function () {' .LM+ .NL)\n"
	"           .OUT('// clear backtrack context on stack' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 3] = -1 ; // input position' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 4] = -1 ; // output position' .NL)\n"
	"           .OUT('this.stack[this.stackframe + 5] = ' 39 39 ' ; // current token' .NL)\n"
	"           .OUT(.LM- '},' .NL .NL)\n"
	"\n"
	"           .OUT('bkrestore: function () {' .LM+ .NL)\n"
	"           .OUT('// restore context for backtracking' .NL)\n"
	"           .OUT('this.eflag = false ;' .NL)\n"
	"           .OUT('this.inp = this.stack[this.stackframe + 3] ;           // input position' .NL)\n"
	"           .OUT('this.outbuf = this.outbuf.substring(0,this.stack[this.stackframe + 4]) ; // output position' .NL)\n"
	"           .OUT('this.token = this.stack[this.stackframe + 5] ;         // current token' .NL)\n"
	"           .OUT(.LM- '}' .NL .NL) ;\n"
	"\n"
	"[ parsing rule definition ]\n"
	"PR = ID .OUT('rule'* ': function () {' .LM+ .NL)\n"
	"     '=' EX1 ';'\n"
	"     .OUT(.LM- '} ,' .NL .NL) ;\n"
	"\n"
	"[ token rule definition ]\n"
	"TR = ID .OUT('rule'* ': function () {' .LM+ .NL)\n"
	"     ':' TX1 ';'\n"
	"     .OUT(.LM- '} ,' .NL .NL) ;\n"
	"\n"
	"[ comment definition ]\n"
	"COMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;\n"
	"\n"
	"[ parsing expressions ]\n"
	"EX1 = EX2 $('/' .OUT('if ((!this.pflag) && (!this.eflag)) {' .LM+ .NL)\n"
	"                EX2\n"
	"                .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT('if (this.pflag) {' .LM+ .NL) /\n"
	"       OUTPUT .OUT('if (true) {' .LM+ .NL) )\n"
	"      .OUT('while (!this.eflag) {' .LM+ .NL)\n"
	"      $(EX3 .OUT('if (!this.pflag) this.bkerr();' .NL)\n"
	"            .OUT('if (this.eflag) break ;' .NL) /\n"
	"        OUTPUT)\n"
	"      .OUT('break }' .LM- .NL)\n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\n"
	"                .OUT('this.rule' * '() ;' .NL)\n"
	"                .OUT('this.ctxpop() ;' .NL) /\n"
	"      STRING    .OUT('this.test(' 39 * 39 ');' .NL) /\n"
	"      '(' EX1 ')'                            /\n"
	"      '.EMPTY'  .OUT('this.pflag = true ;' .NL)    /\n"
	"      '.LITCHR' .OUT('this.token = this.inbuf.charCodeAt(this.inp) ;' .NL)\n"
	"                .OUT('this.inp++ ;' .NL)  /\n"
	"      '.PASS'   .OUT('this.inp = 0 ;' .NL)  /\n"
	"      '$' .OUT('this.pflag = true ;' .NL)\n"
	"          .OUT('while (this.pflag & !this.eflag) {' .LM+ .NL)\n"
	"           EX3 \n"
	"          .OUT(.LM- '} ;' .NL)\n"
	"          .OUT('this.pflag = !this.eflag ;' .NL) /\n"
	"      '[' .OUT('this.bkset() ;' .NL)\n"
	"          EX1\n"
	"          $('|' .OUT('if (!this.pflag) {' .LM+ .NL)\n"
	"                .OUT('if (this.eflag) this.bkrestore() ;' .NL)\n"
	"                EX1\n"
	"                .OUT(.LM- '} ;' .NL) )\n"
	"      ']' .OUT('if (this.eflag) this.bkrestore() ;' .NL)\n"
	"          .OUT('this.bkclear() ;' .NL) ;\n"
	"\n"
	"[ output expressions ]\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' ;\n"
	"\n"
	"OUT1 = '*'     .OUT('this.out(this.token) ;' .NL)          /\n"
	"       STRING  .OUT('this.out(' 39 * 39 ') ;' .NL) /\n"
	"       NUMBER  .OUT('this.out(String.fromCharCode(' * ')) ;' .NL)        /\n"
	"       '#'     .OUT('if (this.stack[this.stackframe + 0] == 0) {' .LM+ .NL) \n"
	"               .OUT('this.stack[this.stackframe + 0] = this.labelcount ;' .NL)\n"
	"               .OUT('this.labelcount++ ; } ;' .LM- .NL) \n"
	"               .OUT('this.out(this.stack[this.stackframe + 0]) ;' .NL) /\n"
	"       '.NL'   .OUT('this.eol() ;' .NL)          /\n"
	"       '.LB'             /\n"
	"       '.TB'   .OUT('this.out(' 39 92 't' 39 ') ;' .NL)          /\n"
	"       '.LM+'  .OUT('this.stack[this.stackframe + 2] += 2 ;' .NL) /\n"
	"       '.LM-'  .OUT('this.stack[this.stackframe + 2] -= 2 ;' .NL) ;\n"
	"\n"
	"[ token expressions ]\n"
	"TX1 = TX2 $('/' .OUT('if (!this.pflag) {' .LM+ .NL) TX2 .OUT(.LM- '} ;' .NL) ) ;\n"
	"\n"
	"TX2 = TX3 .OUT('if (this.pflag) {' .LM+ .NL) \n"
	"      $(TX3 .OUT('if (!this.pflag) return;' .NL) ) \n"
	"      .OUT(.LM- '} ;' .NL) ;\n"
	"\n"
	"TX3 = ( '.TOKEN'  .OUT('this.tflag = true ; ' .NL)\n"
	"                  .OUT('this.token = ' 39 39 ' ;' .NL) /\n"
	"        '.DELTOK' .OUT('this.tflag = false ;' .NL) /\n"
	"        '$' .OUT('this.pflag = true ;' .NL)\n"
	"            .OUT('while (this.pflag) {' .LM+ .NL)\n"
	"             TX3 \n"
	"            .OUT(.LM- '};' .NL) )\n"
	"        .OUT('this.pflag = true ;' .NL) /\n"
	"      '.ANYBUT(' CX1 ')' .OUT('this.pflag = !this.pflag ;' .NL) \n"
	"        .OUT('if (this.pflag) {' .LM+ .NL)\n"
	"        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\n"
	"        .OUT('this.inp++ } ;' .LM- .NL) /\n"
	"      '.ANY(' CX1 ')' \n"
	"        .OUT('if (this.pflag) {' .LM+ .NL)\n"
	"        .OUT('if (this.tflag) this.token += this.inbuf.charAt(this.inp) ;' .NL)\n"
	"        .OUT('this.inp++ } ;' .LM- .NL) /\n"
	"      ID                 \n"
	"        .OUT('this.ctxpush(' 39 * 39 ') ;' .NL)\n"
	"        .OUT('this.rule' * '() ;' .NL)\n"
	"        .OUT('this.ctxpop() ;' .NL)\n"
	"        .OUT('if (this.eflag) return ;' .NL)  /\n"
	"      '(' TX1 ')'  ;\n"
	"\n"
	"[ character expressions ]            \n"
	"CX1 = .OUT('this.pflag = ' .LM+ .NL)\n"
	"      CX2 $('!' .OUT(' ||' .NL) CX2)\n"
	"      .OUT(.LM- ' ;' .NL) ;\n"
	"CX2 = CX3 (':' .OUT('((this.inbuf.charCodeAt(this.inp) >= ' * ') &&' .NL)\n"
	"               CX3\n"
	"               .OUT(' (this.inbuf.charCodeAt(this.inp) <= ' * ')  )' ) /\n"
	"           .EMPTY .OUT('(this.inbuf.charCodeAt(this.inp) == ' * ') ' )  ) ;\n"
	"CX3 = NUMBER / SQUOTE .LITCHR ;\n"
	"\n"
	"[ token definitions ]\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY('A:'Z!'a:'z) ;\n"
	"DIGIT  : .ANY('0:'9) ;\n"
	"SQUOTE : PREFIX .ANY('') ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i02b. demo, AEXP2 backup assignment compiler" ;
	Input[index].text =
	".SYNTAX AEXP2\n"
	"\n"
	"AEXP2 = AS $AS ;\n"
	"AS = ID .OUT(.TB 'address ' * .NL) ':=' RX1 .OUT(.TB 'store' .NL) ';' ;\n"
	"RX1 = RX2 ['='  RX2 .OUT(.TB 'eq' .NL) |\n"
	"           '<'  RX2 .OUT(.TB 'lt' .NL) |\n"
	"           '>'  RX2 .OUT(.TB 'gt' .NL) |\n"
	"           '<=' RX2 .OUT(.TB 'le' .NL) |\n"
	"           '>=' RX2 .OUT(.TB 'ge' .NL) |\n"
	"           .EMPTY] ;\n"
	"RX2 = '~' EX0 .OUT(.TB 'not' .NL) / EX0 ;\n"
	"EX0 = EX1 ('<-' EX1 .OUT(.TB 'shl' .NL) /\n"
	"           '->' EX2 .OUT(.TB 'shr' .NL) /\n"
	"           .EMPTY) ;\n"
	"EX1 = EX2 $['+' EX2 .OUT(.TB 'add' .NL) |\n"
	"            '-' EX2 .OUT(.TB 'sub' .NL) ] ;\n"
	"EX2 = EX3 $('*' EX3 .OUT(.TB 'mpy' .NL) /\n"
	"            '/' EX3 .OUT(.TB 'div' .NL) ) ;\n"
	"EX3 = EX4 $('^' EX3 .OUT(.TB 'exp' .NL)) ;\n"
	"EX4 = '+' EX5 / '-' EX5 .OUT(.TB 'minus' .NL) / EX5 ;\n"
	"EX5 = ID  .OUT(.TB 'load ' * .NL) /\n"
	"      NUMBER .OUT(.TB 'literal ' * .NL) /\n"
	"      '(' EX0 ')' ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN .ANY('A:'Z!'a:'z) $(.ANY('A:'Z!'a:'z) / .ANY('0:'9)) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN .ANY('0:'9) $.ANY('0:'9) .DELTOK ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i04a. Meta II syntax (i03 reordered and tokens)" ;
	Input[index].text =
	".SYNTAX PROGRAM\n"
	"\n"
	"PROGRAM = '.SYNTAX' ID .OUT(.LB .TB 'ADR ' * .NL)\n"
	"          $ ST\n"
	"          '.END' .OUT(.TB 'END' .NL) ;\n"
	"\n"
	"ST = ID .OUT(.LB * .NL) '=' EX1 '.,' .OUT(.TB 'R' .NL) ;\n"
	"\n"
	"EX1 = EX2 $('/' .OUT(.TB 'BT L' # .NL) EX2 )\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(.TB 'BF L' # .NL) / OUTPUT)\n"
	"      $(EX3 .OUT(.TB 'BE' .NL) / OUTPUT)\n"
	"      .OUT(.LB 'L'# .NL) ;\n"
	"\n"
	"EX3 = ID        .OUT(.TB 'CLL '* .NL) /\n"
	"      STRING    .OUT(.TB 'TST '* .NL) /\n"
	"      '.ID'     .OUT(.TB 'ID' .NL)    /\n"
	"      '.NUMBER' .OUT(.TB 'NUM' .NL)   /\n"
	"      '.STRING' .OUT(.TB 'SR' .NL)    /\n"
	"      '(' EX1 ')'             /\n"
	"      '.EMPTY'  .OUT(.TB 'SET' .NL)   /\n"
	"      '$' .OUT(.LB 'L'# .NL) EX3 .OUT(.TB 'BT L' # .NL) .OUT(.TB 'SET' .NL) ;\n"
	"\n"
	"OUTPUT = ('.OUT' '('$OUT1 ')' /\n"
	"          '.LABEL' .OUT(.TB 'LB' .NL) OUT1)\n"
	"         .OUT(.TB 'OUT' .NL) ;\n"
	"\n"
	"OUT1 = '*1'    .OUT(.TB 'GN1' .NL)  /\n"
	"       '*2'    .OUT(.TB 'GN2' .NL)  /\n"
	"       '*'     .OUT(.TB 'CI' .NL)   /\n"
	"       STRING  .OUT(.TB 'CL '* .NL) ;\n"
	"\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .TOKEN .ANY(39) $.ANYBUT(13!10!39) .ANY(39) .DELTOK ;\n"
	"ALPHA  : .ANY('A:'Z!'a:'z) ;\n"
	"DIGIT  : .ANY('0:'9) ;\n"
	"\n"
	".END\n";

	index++ ;
	Input[index].menu = "i16. extract syntax to output" ;
	Input[index].text =
	".SYNTAX SYNTAX\n"
	"[ strip compiler definition to syntax equations in standard form ]\n"
	"[ accepts Meta II and modified syntax ]\n"
	"[ James M. Neighbors ]\n"
	"\n"
	"[ body of compiler definition ]\n"
	"SYNTAX = '.SYNTAX' ID .OUT(.LB '.SYNTAX ' * .NL .NL)\n"
	"         $(PR / COMMENT)  \n"
	"         ( '.TOKENS' .OUT(.LB '.TOKENS' .NL .NL)\n"
	"                     $(TR / COMMENT) \n"
	"                     .OUT(.NL) /\n"
	"           .EMPTY )\n"
	"         '.END' .OUT(.LB '.END' .NL) ;\n"
	"\n"
	"[ parsing rule definition ]\n"
	"PR = ID '=' .OUT(.LB * ' = ' .LM+ ) \n"
	"     EX1 \n"
	"     (';' / '.,') \n"
	"     .OUT(.LM- ';' .NL .NL); \n"
	"\n"
	"[ token rule definition ]\n"
	"TR = ID ':' .OUT(.LB * ' : ' .LM+ ) TX1 ';' .OUT(.LM- ';' .NL ) ; \n"
	"\n"
	"[ comment definition ]\n"
	"COMMENT = '[' CMLINE ']' ;\n"
	"\n"
	"[ parsing expressions ]\n"
	"EX1 = EX2 $('/' .OUT('/ ') EX2 ) ;\n"
	"\n"
	"EX2 = (EX3 .OUT(' ') / OUTPUT) $(EX3 .OUT(' ') / OUTPUT) ;\n"
	"\n"
	"EX3 = ID        .OUT(*)         /\n"
	"      STRING    .OUT(39 * 39)   /\n"
	"      '(' .OUT(.LM+ '( ') \n"
	"          EX1 \n"
	"      ')' .OUT(.LM- ')')        /\n"
	"      '.EMPTY'  .OUT('.EMPTY')  /\n"
	"      '.LITCHR' .OUT('.LITCHR') /\n"
	"      '$' .OUT('$') EX3         /\n"
	"      '.ID'     .OUT('.ID')     /\n"
	"      '.NUMBER' .OUT('.NUMBER') /\n"
	"      '.STRING' .OUT('.STRING') /\n"
	"      '[' .OUT('[ ')\n"
	"          EX1 $('|' .OUT('| ') EX1)\n"
	"      ']' .OUT(']') ;\n"
	"\n"
	"[ output expressions ]\n"
	"OUTPUT = '.OUT' '('$OUT1 ')' / '.LABEL' OUT1 ;\n"
	"\n"
	"OUT1 = '*1'    /\n"
	"       '*2'    /\n"
	"       '*'     /\n"
	"       STRING  /\n"
	"       NUMBER  /\n"
	"       '#'     /\n"
	"       '.NL'   /\n"
	"       '.LB'   /\n"
	"       '.TB'   /\n"
	"       '.LM+'  /\n"
	"       '.LM-'  ;\n"
	"\n"
	"[ token expressions ]\n"
	"TX1 = TX2 $('/' .OUT('/ ') TX2) ; \n"
	"\n"
	"TX2 = TX3 .OUT(' ') $(TX3 .OUT(' ')) ;\n"
	"\n"
	"TX3 = '.TOKEN'         .OUT('.TOKEN') /\n"
	"      '.DELTOK'        .OUT('.DELTOK') /\n"
	"      '$' .OUT('$') TX3  /\n"
	"      '.ANYBUT(' .OUT('.ANYBUT(')\n"
	"          CX1 \n"
	"          ')' .OUT(')')     /\n"
	"      '.ANY(' .OUT('.ANY(')\n"
	"          CX1 \n"
	"          ')' .OUT(')')     /\n"
	"      ID      .OUT(*)       /\n"
	"      '(' .OUT('(') \n"
	"          TX1 \n"
	"      ')' .OUT(')')         ;\n"
	"\n"
	"[ character expressions ]            \n"
	"CX1 = CX2 $('!' .OUT('!') CX2) ;\n"
	"CX2 = CX3 (':' .OUT(':') CX3 /\n"
	"           .EMPTY            ) ;\n"
	"CX3 = NUMBER .OUT(*) / SQUOTE .LITCHR .OUT(*) ;\n"
	"\n"
	"[ token definitions ]\n"
	".TOKENS\n"
	"\n"
	"PREFIX : $.ANY(32!9!13!10) ;\n"
	"ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;\n"
	"NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;\n"
	"STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;\n"
	"ALPHA  : .ANY('A:'Z!'a:'z) ;\n"
	"DIGIT  : .ANY('0:'9) ;\n"
	"SQUOTE : PREFIX .ANY('') ;\n"
	"CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;\n"
	"\n"
	".END\n";

	*return_count = index;

}








